<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StarBlog!</title>
  
  <subtitle>Blog for starydy</subtitle>
  <link href="http://starydy.xyz/atom.xml" rel="self"/>
  
  <link href="http://starydy.xyz/"/>
  <updated>2023-09-14T12:11:58.196Z</updated>
  <id>http://starydy.xyz/</id>
  
  <author>
    <name>Star YDY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RA-L Active Implicit Recon</title>
    <link href="http://starydy.xyz/2023/08/31/RA-L%20Active%20Implicit%20Recon/"/>
    <id>http://starydy.xyz/2023/08/31/RA-L%20Active%20Implicit%20Recon/</id>
    <published>2023-08-31T10:50:12.000Z</published>
    <updated>2023-09-14T12:11:58.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Our-Paper-is-accepted-by-RA-L2023"><a href="#Our-Paper-is-accepted-by-RA-L2023" class="headerlink" title="Our Paper is accepted by RA-L2023!"></a>Our Paper is accepted by RA-L2023!</h2><p>Title: <strong>Active Implicit Object Reconstruction using Uncertainty-guided Next-Best-View Optimization</strong></p><p>github link: <a href="https://github.com/HITSZ-NRSL/ActiveImplicitRecon">github.com/HITSZ-NRSL/ActiveImplicitRecon</a></p><p align="center">  <img width="100%" src="http://starydy.xyz/images/ActiveRecon/overview.png"/></p><p>If you find this work useful, please cite:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ARTICLE&#123;10223307,</span><br><span class="line">  author&#x3D;&#123;Yan, Dongyu and Liu, Jianheng and Quan, Fengyu and Chen, Haoyao and Fu, Mengmeng&#125;,</span><br><span class="line">  journal&#x3D;&#123;IEEE Robotics and Automation Letters&#125;, </span><br><span class="line">  title&#x3D;&#123;Active Implicit Object Reconstruction using Uncertainty-guided Next-Best-View Optimization&#125;, </span><br><span class="line">  year&#x3D;&#123;2023&#125;,</span><br><span class="line">  volume&#x3D;&#123;&#125;,</span><br><span class="line">  number&#x3D;&#123;&#125;,</span><br><span class="line">  pages&#x3D;&#123;1-8&#125;,</span><br><span class="line">  doi&#x3D;&#123;10.1109&#x2F;LRA.2023.3306282&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Our-Paper-is-accepted-by-RA-L2023&quot;&gt;&lt;a href=&quot;#Our-Paper-is-accepted-by-RA-L2023&quot; class=&quot;headerlink&quot; title=&quot;Our Paper is accepted by R</summary>
      
    
    
    
    <category term="日常" scheme="http://starydy.xyz/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>ICRA2023</title>
    <link href="http://starydy.xyz/2023/02/14/[ICRA2023]EINRUL:%20Efficient%20Implicit%20Neural%20Reconstruction%20Using%20LiDAR/"/>
    <id>http://starydy.xyz/2023/02/14/[ICRA2023]EINRUL:%20Efficient%20Implicit%20Neural%20Reconstruction%20Using%20LiDAR/</id>
    <published>2023-02-14T02:50:12.000Z</published>
    <updated>2023-09-14T12:11:58.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Our-Paper-is-accepted-by-ICRA2023"><a href="#Our-Paper-is-accepted-by-ICRA2023" class="headerlink" title="Our Paper is accepted by ICRA2023!"></a>Our Paper is accepted by ICRA2023!</h2><p>Title: <strong>Efficient Implicit Neural Reconstruction Using LiDAR</strong></p><p>github link: <a href="https://github.com/StarRealMan/EINRUL">github.com/StarRealMan/EINRUL</a></p><p>project page: <a href="https://starydy.xyz/EINRUL">starydy.xyz/EINRUL</a></p><p align="center">  <img width="100%" src="http://starydy.xyz/EINRUL/static/images/overview.png"/></p><p>If you find this work useful, please cite:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@InProceedings&#123;yan2023efficient,</span><br><span class="line">  author &#x3D; &#123;Dongyu Yan, Xiaoyang Lyu, Jieqi Shi, Yi Lin&#125;,</span><br><span class="line">  title &#x3D; &#123;Efficient Implicit Neural Reconstruction Using LiDAR&#125;,</span><br><span class="line">  booktitle&#x3D;&#123;2023 IEEE International Conference on Robotics and Automation (ICRA)&#125;,</span><br><span class="line">  year &#x3D; &#123;2023&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Our-Paper-is-accepted-by-ICRA2023&quot;&gt;&lt;a href=&quot;#Our-Paper-is-accepted-by-ICRA2023&quot; class=&quot;headerlink&quot; title=&quot;Our Paper is accepted by I</summary>
      
    
    
    
    <category term="日常" scheme="http://starydy.xyz/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>ICRA投稿后对未来自己的期待</title>
    <link href="http://starydy.xyz/2022/09/13/ICRA%E6%8A%95%E7%A8%BF%E5%90%8E%E5%AF%B9%E6%9C%AA%E6%9D%A5%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%9F%E5%BE%85/"/>
    <id>http://starydy.xyz/2022/09/13/ICRA%E6%8A%95%E7%A8%BF%E5%90%8E%E5%AF%B9%E6%9C%AA%E6%9D%A5%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%9F%E5%BE%85/</id>
    <published>2022-09-13T09:50:00.000Z</published>
    <updated>2023-09-14T12:11:58.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="After-Paper-Submission"><a href="#After-Paper-Submission" class="headerlink" title="After Paper Submission"></a>After Paper Submission</h2><p>忙前忙后一个月，终于把这篇抱着试试看心态做完的论文投出去了。<br>另外还有一篇之前没中的NIPS，也跟着一起投出去了。（真是初生牛犊不怕虎，现在看看NIPS的文章水平，与自己的差距还很大，觉得当时自己真是太勇了！）<br>不知道这两篇文章的前途会如何，但是会始终保持着从事科研的初心——希望能把自己的好想法带给更多人。</p><p>在这期间，看到了很多志同道合的朋友，他们的作品，让我觉得很佩服，也很羡慕。<br>他们有着天马行空的想法，也有着实现这些想法的能力。<br>他们能够不费吹灰之力地将自己的作品用精彩的行文，精密的实验以及精妙的视频展示出来，让我感觉自己，还有许多地方该向他们学习。</p><p>写完人生中第二篇论文，我对科研的真理也有了进一步的认识，对自己也有了更高的期待。<br>我希望自己以后能够：</p><ol><li>每天阅读文献，紧跟领域前沿</li><li>提升知识的深度，深入钻研本领域文章</li><li>扩大知识的广度，了解其他方领域发展</li><li>有发现问题的眼睛，有思考问题的头脑</li><li>要有想法，更要有验证想法的的能力与实现想法的动力</li></ol><p>在此对我的科研生涯寄托如此的目标，希望未来的我能够不忘初心，砥砺前行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;After-Paper-Submission&quot;&gt;&lt;a href=&quot;#After-Paper-Submission&quot; class=&quot;headerlink&quot; title=&quot;After Paper Submission&quot;&gt;&lt;/a&gt;After Paper Submissi</summary>
      
    
    
    
    <category term="日常" scheme="http://starydy.xyz/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>震惊？！小伙儿竟然重现了CSGO中的经典地图（第一话）</title>
    <link href="http://starydy.xyz/2021/11/24/%E9%9C%87%E6%83%8A%EF%BC%9F%EF%BC%81%E5%B0%8F%E4%BC%99%E5%84%BF%E7%AB%9F%E7%84%B6%E9%87%8D%E7%8E%B0%E4%BA%86CSGO%E4%B8%AD%E7%9A%84%E7%BB%8F%E5%85%B8%E5%9C%B0%E5%9B%BE%EF%BC%88%E7%AC%AC%E4%B8%80%E8%AF%9D%EF%BC%89/"/>
    <id>http://starydy.xyz/2021/11/24/%E9%9C%87%E6%83%8A%EF%BC%9F%EF%BC%81%E5%B0%8F%E4%BC%99%E5%84%BF%E7%AB%9F%E7%84%B6%E9%87%8D%E7%8E%B0%E4%BA%86CSGO%E4%B8%AD%E7%9A%84%E7%BB%8F%E5%85%B8%E5%9C%B0%E5%9B%BE%EF%BC%88%E7%AC%AC%E4%B8%80%E8%AF%9D%EF%BC%89/</id>
    <published>2021-11-24T13:50:43.000Z</published>
    <updated>2023-09-14T12:11:58.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>作为一名自身CSGO玩家，我始终有一个梦想，就是把我的家——炼狱小镇，使用三维重建的方法重建出来，进行稠密三维重建，我们需要的模块包括：</p><ul><li>单目深度</li><li>里程计</li><li>地图融合</li></ul><p>我们的原则是尽量少使用读取游戏内存的方法（也就是市面上大多数外挂的方法），仅使用屏幕获取图像完成这一任务。</p><p>第一步！获取弹幕深度估计。拜读了众多单目深度估计网络，发现他们主要可以分为三大类：</p><ol><li>有深度监督</li><li>双目自监督</li><li>视频流自监督</li></ol><p>由于我们无法获取CSGO图像中的深度信息，也无法在CSGO中使用双目相机，于是我们选择了依赖最少，仅需要视频流就可以训练的第三种方法：视频流自监督。</p><p>他的大致原理是：使用<strong>POSE NET</strong>进行位姿估计，在使用<strong>DEPTH NET</strong>进行深度估计，最后使用<strong>光度误差</strong>进行监督训练。我们选取了开源的<strong>Monodepth2</strong>作为codebase进行训练。</p><p><img src="/images/2021/%E9%9C%87%E6%83%8A%EF%BC%9F%EF%BC%81%E5%B0%8F%E4%BC%99%E5%84%BF%E7%AB%9F%E7%84%B6%E9%87%8D%E7%8E%B0%E4%BA%86CSGO%E4%B8%AD%E7%9A%84%E7%BB%8F%E5%85%B8%E5%9C%B0%E5%9B%BE%EF%BC%88%E7%AC%AC%E4%B8%80%E8%AF%9D%EF%BC%89/monodepth2.gif" alt="Monodepth2展示效果"></p><h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a><strong>数据采集</strong></h2><h2 id="相机参数标定"><a href="#相机参数标定" class="headerlink" title="相机参数标定"></a><strong>相机参数标定</strong></h2><h2 id="MonoDepth2训练"><a href="#MonoDepth2训练" class="headerlink" title="MonoDepth2训练"></a><strong>MonoDepth2训练</strong></h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;作为一名自身CSGO玩家，我始终有一个梦想，就是把我的家——炼狱小镇，使用三维重建的方法重建出来，进行稠密</summary>
      
    
    
    
    <category term="开发" scheme="http://starydy.xyz/categories/%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>涡流制动综述</title>
    <link href="http://starydy.xyz/2021/09/22/%E6%B6%A1%E6%B5%81%E5%88%B6%E5%8A%A8%E7%BB%BC%E8%BF%B0/"/>
    <id>http://starydy.xyz/2021/09/22/%E6%B6%A1%E6%B5%81%E5%88%B6%E5%8A%A8%E7%BB%BC%E8%BF%B0/</id>
    <published>2021-09-22T15:10:17.000Z</published>
    <updated>2023-09-14T12:11:58.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0 引言"></a><strong>0 引言</strong></h2><p>在阅读这篇文章的各位在高中物理中应该都接触过涡流的概念。如果没记错的话，高中物理有这么一个演示实验，说把一块圆柱形磁铁和一块没有磁性的圆柱形钢，把他俩从等高的铜管中扔下去，磁铁落地要比钢慢。今天要讲的就是如何把这个东西用到轨道交通中。</p><h2 id="1涡流制动的原理"><a href="#1涡流制动的原理" class="headerlink" title="1涡流制动的原理"></a><strong>1涡流制动的原理</strong></h2><p><strong>1.1涡流产生的原理</strong></p><p>在电工设备中，大块的导体处在交变的磁场中时，内部会出现呈涡旋状的感应电流，即为涡旋电流，简称涡流。涡流能够在导体内部自动形成闭合回路，呈涡旋状流动。涡流在导体中流动时会引起导体发热，与普通电流一样具有热效应；涡流也会产生磁场，磁场的方向是阻碍外部磁场的变化，具有去磁效应；产生涡流的同时伴随着制动力和制动力矩的产生，称为涡流的机械效应。<br>利用涡流的热效应，可制成电磁炉，工业上可用于金属的加热冶炼过程。在发电机和变压器等大量使用硅钢片的设备的铁心、端盖中，需要设法尽量减小涡流（如合理规划硅钢片的叠压方式等），以避免较大的能量损失。</p><p><strong>1.2涡流产生制动力或力矩的原理</strong></p><p>法拉第电磁感应定律和楞次定律指出，感应电流产生的磁场总是阻碍原磁场磁通的变化。这其实包含两类情况：第一类是磁场和承载感应电流的导体不发生相对运动，仅存在磁通在固定位置上随时间的交变；第二类是磁场为恒定磁场（直流励磁），导体与磁场间有相对运动。这两类情况分别对应产生感生电动势和动生电动势。由于产生制动的前提是有物体在做机械运动，因此涡流制动对应第二类情况。<br>国内外文献普遍倾向于采用楞次定律解释制动力和力矩产生的原理。此外还有观点认为，涡流会因为洛伦兹力的产生使物体有停止运动的趋势。<br>从场的角度分析，磁场是直流励磁，主磁通不变，导体在磁场中发生相对运动。在此过程中产生涡流，涡流产生的磁场的方向是阻碍原磁通变化，即阻碍相对运动，因此会产生制动力或制动力矩。<br>从能量角度分析，由于磁场是恒定的，励磁部分的有功功率仅由绕组自身电阻产生的焦耳热构成，励磁一侧的电源不会通过磁场向外提供能量。对于运动的部分，当速度减小时，机械能通过洛伦兹力转化为涡流发热。<br>涡流制动的突出优点是无机械磨损、无气味、无噪声, 在很大的速度范围内制动力具有平坦的特性, 且制动力可控, 即可用于紧急制动, 又可用于常用制动, 可部分替代摩擦制动, 减少制动盘、闸片的磨损和更换。 </p><h2 id="2涡流制动的分类"><a href="#2涡流制动的分类" class="headerlink" title="2涡流制动的分类"></a><strong>2涡流制动的分类</strong></h2><p>涡流制动主要分为盘式和线性两种。<br>盘式涡流制动是将制动盘与轮对同轴布置，在制动盘的轴向方向上交替布置电磁铁，使磁场沿轴向穿过制动盘。制动盘随轮对转动，当触发制动时，制动盘在轴向恒定磁场中转动，内部产生涡流，从而产生制动转矩。</p><p><img src="/images/2021/%E6%B6%A1%E6%B5%81%E5%88%B6%E5%8A%A8%E7%BB%BC%E8%BF%B0/%E5%9B%BE2.1(a)%E7%9B%98%E5%9E%8B%E6%B6%A1%E6%B5%81%E5%88%B6%E5%8A%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图2.1(a)盘型涡流制动示意图"><br><img src="/images/2021/%E6%B6%A1%E6%B5%81%E5%88%B6%E5%8A%A8%E7%BB%BC%E8%BF%B0/%E5%9B%BE2.1(b)%E7%9B%98%E5%9E%8B%E6%B6%A1%E6%B5%81%E5%88%B6%E5%8A%A8%E5%AE%9E%E9%99%85%E8%A3%85%E7%BD%AE.jpg" alt="图2.1(b)盘型涡流制动实际装置"><br>图2.1 盘形涡流制动</p><p>线性涡流制动（WB）装置与磁轨制动类似。磁轨制动是将电磁铁沿铁轨方向线形布置，触发制动时电磁铁产生吸力，磁轨装置与铁轨接触摩擦制动。线形涡流制动装置和作动过程与磁轨制动类似，但制动装置与轨道不发生接触和摩擦，触发制动时安装在转向架上的电磁铁励磁，铁轨中产生涡流，在反作用力的作用下产生制动力。</p><p><img src="/images/2021/%E6%B6%A1%E6%B5%81%E5%88%B6%E5%8A%A8%E7%BB%BC%E8%BF%B0/2.2%E7%BA%BF%E6%80%A7%E6%B6%A1%E6%B5%81%E5%88%B6%E5%8A%A8.png" alt="图2.2 线性涡流制动"></p><p>盘式涡流制动和线性涡流制动的区别在于，盘式涡流制动产生涡流的导体是随轮对同轴转动的制动盘，由此产生的制动转矩作用于制动盘上，而线性涡流制动产生涡流的导体是轨道，相当于轨道受到一个来自车体的沿列车运动方向向前的力，其反作用力作为反向制动力作用于车体。</p><h2 id="3实际应用"><a href="#3实际应用" class="headerlink" title="3实际应用"></a><strong>3实际应用</strong></h2><p>涡流制动在汽车缓速器和高速动车组的制动装置等中有所应用。下面主要列举应用于高速动车组的涡流制动装置。</p><p><strong>3.1盘式涡流制动的应用</strong></p><p>日本新干线的部分车型使用了盘式涡流制动装置。新干线制动方式如下图所示</p><p><img src="/images/2021/%E6%B6%A1%E6%B5%81%E5%88%B6%E5%8A%A8%E7%BB%BC%E8%BF%B0/3.1%E6%96%B0%E5%B9%B2%E7%BA%BF%E5%88%B6%E5%8A%A8%E6%96%B9%E5%BC%8F.png" alt="图3.1 新干线制动方式"></p><p>新干线利用851型试验电动车组进行了涡流制动装置的试验，但考虑到轨道发热问题，最终选择了盘式制动装置。100系、300系、700系动车组在拖车上均采用了盘式涡流制动和空气盘式制动的组合方式。其中，300系每轴配备2套，而700系为减轻拖车轴重减少为1套。300系常用制动能量分配为：再生制动占62%，涡流制动占35%，机械制动占3%。近年来，日本开始研究交流励磁的涡流制动装置。</p><p><strong>3.2线性涡流制动的应用</strong></p><p>线性涡流制动在法国AGV列车和德国ICE3列车上有所应用。<br>法国曾在TGV—001燃气轮高速动车组Y225型转向架基础上进行过盘式涡流制动装置的试验，1972到1973年法国国营铁路对线性涡流制动装置进行了试验。在TGV的改进版本AGV列车上安装了线性涡流制动装置，但阿尔斯通认为涡流制动装置质量大且价格高，最终AGV仅在第一台和最后一台转向架上设置了涡流制动装置，当行车速度在200km/h至350km/h时，每台转向架的涡流制动装置在正常制动时可产生10kN的制动力，并可产生20kN的紧急制动力。在线路上行车间隔为3分钟的情况下，轨道中的发热和由电磁铁产生的垂向力处在可以承受的范围内。<br>德国从上世纪70年代开始研究涡流制动技术。从1985年起，德国铁路利用ICE/V高速试验动车组进行了长期的线性涡流制动试验。随着新材料的发展，1996年成功研制了新型电磁线圈，解决了电磁铁的轻量化和轨道匹配问题，1998至2000年在ICE—S上进行了全面的试验和运用考核。在正式投入商业运营的ICE3动车组上批量使用了线性涡流制动装置，可提供145kN的完全常用制动力和175kN的紧急制动力。</p><p><img src="/images/2021/%E6%B6%A1%E6%B5%81%E5%88%B6%E5%8A%A8%E7%BB%BC%E8%BF%B0/3.2ICE3%E5%88%B6%E5%8A%A8%E5%8A%9B%E4%B8%8E%E9%80%9F%E5%BA%A6%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="图3.2 ICE3制动力与速度的关系"></p><p>ICE3上的线性涡流制动装置使用的电磁铁由8个串联的磁极夏暖组成，通过螺栓与纵向支撑梁连接，磁极交替布置。</p><p><img src="/images/2021/%E6%B6%A1%E6%B5%81%E5%88%B6%E5%8A%A8%E7%BB%BC%E8%BF%B0/3.3ICE3%E4%BD%BF%E7%94%A8%E7%9A%84%E7%BA%BF%E6%80%A7%E6%B6%A1%E6%B5%81%E5%88%B6%E5%8A%A8%E8%A3%85%E7%BD%AE.jpg" alt="图3.3 ICE3使用的线性涡流制动装置"></p><p>在试验过程中，WB对轨道旁的计轴器等设备产生了一定的干扰。ICE3上涡流制动装置通过的电流最大值可达100A，其周围会产生比较强的磁场，导致部分设备受干扰而失效。</p><h2 id="4两种涡流制动的优缺点比较"><a href="#4两种涡流制动的优缺点比较" class="headerlink" title="4两种涡流制动的优缺点比较"></a><strong>4两种涡流制动的优缺点比较</strong></h2><p>盘式涡流制动的主要优点有：不受轨道线路的限制；制动盘的材料可以选择；可以在既有车辆上补装。盘式涡流制动的主要缺点有：属于黏着制动，虽然可减少磨耗，但对告诉条件下提高制动减速度的作用不大。<br>线性涡流制动的主要优点有：属于飞黏着制动方式，不依赖于轮轨黏着系数；可产生较大的制动力，减小制动距离，适用于高速；相比于磁轨制动不会对轨道产生冲击。线性涡流制动的主要缺点有：会导致钢轨发热，不利于频繁制动；低速时电磁吸力很大，不适合低速环境；电磁铁产生的电磁场对轨道电路的干扰作用，对轨旁设备的工作可能会有一定干扰。</p><h2 id="5总结"><a href="#5总结" class="headerlink" title="5总结"></a><strong>5总结</strong></h2><p>涡流制动并不是一种新技术，在汽车缓速器和列车制动方面都有应用。应用于列车的涡流制动技术主要分为盘式和线性两种。对于未来更高速度的高速动车组，在盘形制动和再生制动的基础上有必要引入涡流制动这种额外的制动方式，进一步提升列车的安全性能。研究涡流制动时要考虑到制动装置对轴重、轨道电路、轨旁设备的影响，避免对列车性能和行车安全产生负面影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0-引言&quot;&gt;&lt;a href=&quot;#0-引言&quot; class=&quot;headerlink&quot; title=&quot;0 引言&quot;&gt;&lt;/a&gt;&lt;strong&gt;0 引言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在阅读这篇文章的各位在高中物理中应该都接触过涡流的概念。如果没记错的话，高中物理有这么一个</summary>
      
    
    
    
    <category term="日常" scheme="http://starydy.xyz/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>矩阵分解二三事</title>
    <link href="http://starydy.xyz/2021/08/20/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <id>http://starydy.xyz/2021/08/20/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/</id>
    <published>2021-08-20T09:21:42.000Z</published>
    <updated>2023-09-14T12:11:58.196Z</updated>
    
    <content type="html"><![CDATA[<p>在学习线性代数的过程中常常遇到矩阵分解这个概念，从名字来看，大概就是A=PQ或者A=UVW这样的事情，但是，我们为什么要进行矩阵分解？各种矩阵分解具体是怎样实现的 ？种种问题始终困扰着我，这次我们来个大杂烩，深入理解矩阵分解的奥秘。</p><h2 id="LU分解"><a href="#LU分解" class="headerlink" title="LU分解"></a>LU分解</h2><p>说到最常见的矩阵分解，必然是LU分解，LU分解将满秩的方阵分解为一个下三角矩阵X一个上三角矩阵的形式，他在我么们进行高斯消元时就发挥了作用，具体是怎样实现的呢？</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/LU.png" alt="LU"></p><p>回忆高斯消元的过程，我们总是使用初等行变换，使用第一行消去其下面每行的第一列，使用第二行消去下面每行的第二列，最终的结果就是我们能得到一个上三角矩阵。需要注意的是过程中不能出现行交换的初等变换。</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/U.png" alt="U"></p><p>而大家又可得知，进行初等行变换，可以看做分解为左乘行变换矩阵的过程，而这些行变换矩阵的积总是一个下三角矩阵。</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/L.png" alt="L"></p><p>这样看下来，LU分解就是代表着高斯消元的过程。LU分解主要应用于求解线性方程Ax = b中，最容易想到的方法是求A的逆，但是这样费时费力，小学生最先想到的方法则是高斯消元，可以用LU分解的方式表示：</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/1.png" alt="1"><br><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/2.png" alt="2"><br><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/3.png" alt="3"></p><p>由于三角阵的逆很容易求得，我们很快就能求解x。</p><h2 id="Cholesky分解"><a href="#Cholesky分解" class="headerlink" title="Cholesky分解"></a>Cholesky分解</h2><p>如果LU分解中的A矩阵同时也是一个对称正定矩阵的话，此时进行的LU分解也可看作是Cholesky分解。</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/Cholesky.png" alt="Cholesky"></p><p>Cholesky分解类似于求解矩阵的平方根，在无迹卡尔曼滤波（UKF）中，求取Sigma点时使用的数值解方法就利用了Cholesky分解。</p><h2 id="QR分解"><a href="#QR分解" class="headerlink" title="QR分解"></a>QR分解</h2><p>相较于要求严格的LU分解，对于任意的方阵，我们都能对其进行QR分解，其可以将一个方阵分解为一个正交矩阵X一个上三角矩阵的形式。</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/QR.png" alt="QR"></p><p>再让我们回忆一下Gram-Schmidt正交化。G-S正交化的作用是将原来表示子空间的基变为一组子空间的正交基来代表这个子空间，有了正交基，子空间中的向量就可以进一步使用正交坐标系统来表示了。G-S分解的过程非常简单就是不断地将下一个基减掉其在已经求得的正交基上的投影，得到的结果也就是在其他正交基方向上没有的部分，也就是新的正交基。</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/G-S.png" alt="G-S"></p><p>QR分解描述的就是这个过程：A中的列向量就是原本描述子空间的基，而结果中的Q即是描述子空间的新基，由于其正交的性质，Q也就成了一个正交矩阵，结果中的R代表着老基在新基中的坐标，由G-S正交化的过程可以看出，R可以表示为一个上三角矩阵。</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/QRM.png" alt="QRM"></p><p>你有没有注意到上面所说的G-S分解是可以作用于子空间的，而我们说QR分解只能够作用于方阵，也就是这个子空间就是原空间本身！这样是不是限制了G-S分解的发挥呢？确实是如此，因此我们推广了QR分解，也就是广义的QR分解：</p><p>对于矩阵A（维度：mXn），若m &gt; n，则可以将A矩阵的列向量看做是描述了一个m维空间中的n维子空间，这时我们同样能够对A进行G-S正交化，可以得到n个m维的正交基与n个n维的系数向量，这时的QR分解可以描述为：</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/QRG.png" alt="QRG"></p><p>此时的R矩阵仍然是上三角矩阵，而Q则不再是正交矩阵了。但是我们可以使用脑补的方法帮助Q脑补一些正交的向量作为基，使得这组基能够描述整个空间，凑齐m个基，就能够将W矩阵脑补成一个正交矩阵了，只不过此时的R矩阵由于并没有利用到脑补出来的向量，则会产生数行全0的系数向量，这时的QR分解可以描述为：</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/QRN.png" alt="QRN"></p><p>QR分解的应用也在于求解方程组Ax=b当中，只不过这次涉及到了子空间，所以这个方程组可能是一个超定的方程组，我们要利用上文提到的广义QR分解第二种形式，简化求解最小二乘问题，过程如下：</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/LS.png" alt="LS"><br><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/dealLS.png" alt="dealLS"></p><p>最后变为求解<img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/resLS.png" alt="resLS">的问题，是一个全定的问题。</p><h2 id="特征值分解（谱分解）"><a href="#特征值分解（谱分解）" class="headerlink" title="特征值分解（谱分解）"></a>特征值分解（谱分解）</h2><p>特征值大家都很熟悉，其实特征值分解大家也都有所了解，他的求解过程完全就是利用了特征值的定义：</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/EigenValue.png" alt="EigenValue"></p><p>如果A是方阵（维度：nXn），且拥有n个线性无关的特征向量，则利用特征值与特征向量的定义，可以将其组合，整理为：</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/AQQS.png" alt="AQQS"></p><p>其中Q是特征向量作为列向量组合承德矩阵，由于特征向量线性无关，Q可逆的；Sigma是对应特征值构成的对角矩阵。最终特征值分解可表示为：</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/Eigen.png" alt="Eigen"></p><p>特征值分解的意义在于，它描述了矩阵A的基本性质。若将A视为一个线性变换矩阵，A的作用就是某个向量x变换为某个向量b，也就是Ax=b的过程。我们很难理解这个变换，但是我们可以使用特征值分解，将其拆分为：Q变换逆-Sigma变换-Q变换 的过程。其中Sigma描述了变换的缩放关系。特征值分解将一个复杂的变换描述为了两个简单的变换：一个坐标系的转换与一个缩放的变换。</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/Trans.png" alt="Trans"><br><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/Trans2.png" alt="Trans2"><br><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/Scale.png" alt="Scale"></p><p>特别地，若A矩阵为实对称阵，则其不同特征值对应的特征向量互相正交，于是我们求得的Q矩阵变成了正交矩阵（描述一个旋转），对应的特征值分解也变成了：</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/Sym.png" alt="Sym"></p><h2 id="奇异值分解（SVD）"><a href="#奇异值分解（SVD）" class="headerlink" title="奇异值分解（SVD）"></a>奇异值分解（SVD）</h2><p>与特征值分解类似，奇异值分解也致力于寻找这样的描述变换本质的坐标变换+缩放，但是他所针对的目标在于描述任意矩阵而非仅针对于方阵。奇异值分解的形式为：</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/Sigular.png" alt="Sigular"></p><p>求解奇异值分解的方法很浅显易懂，既然方阵能够进行特征值分解，我们不如直接构造一个方阵，比如说，想要求解矩阵A（维度：mXn）的奇异值分解，我们构造：</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/ATA.png" alt="ATA"></p><p>我们注意到这个M矩阵（维度：nXn）是一个对称阵，它的特征值分解会得到Q是一个nxn的正交矩阵，Sigma是一个nXn的对角矩阵，将奇异值分解的定义代入，可以得到：</p><p><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/Eq.png" alt="Eq"><br><img src="/images/2021/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E4%BA%8C%E4%B8%89%E4%BA%8B/Eq2.png" alt="Eq2"></p><p>显而易见我们可以得到此时的Q即是奇异值分解中的V。同样的，计算AAT则可以得到U的值。Sigma的值也可以容易地求得。需要注意的是，Sigma是包含0行或0列的准对角矩阵，对角线元素是ATA或AAT特征值的根。</p><p>奇异值分解描述了任意一个矩阵的本质，他有很多的应用：</p><ol><li>在PCA降维中，对矩阵A使用奇异值分解，去除结果中非主要元素的Sigma以及对应的U、V中的向量，仍能较好地还原矩阵A，此时奇异值分解描述的是矩阵元素的协方差。</li><li>在対极几何中，得到本质矩阵或基础矩阵，通常使用奇异值分解得到对应的R与t。</li><li>ICP点云配准中也是用奇异值分解得到对应的R与t。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在学习线性代数的过程中常常遇到矩阵分解这个概念，从名字来看，大概就是A=PQ或者A=UVW这样的事情，但是，我们为什么要进行矩阵分解？各种矩阵分解具体是怎样实现的 ？种种问题始终困扰着我，这次我们来个大杂烩，深入理解矩阵分解的奥秘。&lt;/p&gt;
&lt;h2 id=&quot;LU分解&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="物数" scheme="http://starydy.xyz/categories/%E7%89%A9%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>老婆不够D？那就自己造！</title>
    <link href="http://starydy.xyz/2021/07/10/%E8%80%81%E5%A9%86%E4%B8%8D%E5%A4%9FD%EF%BC%9F%E9%82%A3%E5%B0%B1%E8%87%AA%E5%B7%B1%E9%80%A0%EF%BC%81/"/>
    <id>http://starydy.xyz/2021/07/10/%E8%80%81%E5%A9%86%E4%B8%8D%E5%A4%9FD%EF%BC%9F%E9%82%A3%E5%B0%B1%E8%87%AA%E5%B7%B1%E9%80%A0%EF%BC%81/</id>
    <published>2021-07-10T12:10:37.000Z</published>
    <updated>2023-09-14T12:11:58.196Z</updated>
    
    <content type="html"><![CDATA[<p>神经网络真是个神奇的东西，它既能识别图像中的物品属于哪一种类，又能定位视频中目标，甚至能够听懂人类的语言，简直就是无所不能！可你是否想过，神经网络甚至能够进行创作，能够生成世界上根本不存在的东西呢？</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>随着最近AI换脸的火爆，一个特别的神经网络再次走进了人们的视野，他就是生成对抗神经网络（GAN）。就像上文描述的，它能够生成世界上根本不存在的物体，也就是进行创作！</p><p>你一定很想知道，他是怎样进行创作的呢？他与其他种类的神经网络有什么本质区别呢？他的基本原理是如何呢？</p><p>GAN通常由两个基本结构组成，一个是<strong>Discriminator</strong>，也叫判别器，另一个是<strong>Generator</strong>，也叫生成器。生成器的作用很好理解，就是将一个高维的隐向量转换为一张图片，当然这张图片一定是越能够“以假乱真”，越好。按照传统的神经网络设计方法，我们只需要训练这个网络，使得网络拟合一个从高维隐向量空间到目标图片的任务空间的函数即可，这就涉及到一个问题，网络怎样才能学会我们想要的图片是怎样的呢？我们怎样监督这个网络呢？</p><p>于是，聪明的Ian J. Goodfellow发明了这样一种训练方式：设计一种判别器，能够判断图片是否由生成器生成，再对生成器生成的图片进行评价，进而对生成器进行了监督。想法很好，可是这种判别器该怎样得到呢？别着急，在论文中，Goodfellow将判别器和生成器进行了结合使得二者同时训练，判别器使用外部数据作为正样本，使用生成器生成图片作为负样本进行监督，而生成器则通过判别器进行监督，二者相互学习，互相对抗，这也是网络被称为生成<strong>对抗</strong>神经网络的原因。</p><p>网络的Loss设计成如下形式：</p><p><img src="/images/2021/%E8%80%81%E5%A9%86%E4%B8%8D%E5%A4%9FD%EF%BC%9F%E9%82%A3%E5%B0%B1%E8%87%AA%E5%B7%B1%E9%80%A0%EF%BC%81/loss.png" alt="loss function"></p><p>网络的基本步骤如下：</p><ol><li>使用真实数据作为正样本训练D网络</li><li>使用G网络生成数据作为负样本训练D网络（此时使用detach，不影响G网络参数）</li><li>不进行detach，将G网络生成数据送入D网络进行训练（此时只更新G网络参数，不影响D网络参数）</li></ol><p>经过上述步骤的反复迭代，最终D网络想要趋向于能够很精准的判断图片是来自真实分布还是来自于G网络的生成，同时G网络会努力地生成不被D网络发现为假的图片，二者就像矛和盾一样互相对抗，最终二者都能够学到真实样本深层次的分布特征。</p><p>在进行inference时，只需使用G网络即可产生想要的全新图片（同时D网络也可以用来进行真伪辨别等工作）</p><h3 id="进行实验"><a href="#进行实验" class="headerlink" title="进行实验"></a>进行实验</h3><p>作为一个老二次元，GAN这东西能生成不存在物体的特性，不拿来用用生成二次元老婆实在是说不过去啊，于是我借鉴DCGAN这篇经典论文，搭建了一个最简单的GAN网络，能够学习老婆们的特征，进而生成新的老婆，真是太香了！</p><p>Github：<a href="https://github.com/StarRealMan/Waifu_Generator">Waifu_Generator</a></p><p>原始DCGAN改进之前GAN使用的全连接层，D、G网络均使用卷积层进行特征提取，使用很浅的5层网络，最终能够生成64X64分辨率的图片。</p><p>我使用的数据集来源于Waifu2x，同样也是GAN领域著名的超分辨率方法得到的256X256分辨率的二次元老婆数据集，共有20000左右的样本，如下图所示：</p><p><img src="/images/2021/%E8%80%81%E5%A9%86%E4%B8%8D%E5%A4%9FD%EF%BC%9F%E9%82%A3%E5%B0%B1%E8%87%AA%E5%B7%B1%E9%80%A0%EF%BC%81/real_samples.png" alt="real samples"></p><p>这是使用原生DCGAN训练50轮生成的图片：</p><p><img src="/images/2021/%E8%80%81%E5%A9%86%E4%B8%8D%E5%A4%9FD%EF%BC%9F%E9%82%A3%E5%B0%B1%E8%87%AA%E5%B7%B1%E9%80%A0%EF%BC%81/fake_samples_epoch_049.png" alt="dcgan result"></p><p>我们拿着这么好的数据，难道会只满足于如此低分辨率图片的生成吗？于是我们对网络进行了进一步的改进，增加了深度到7层，增加分辨率到256X256，同时加大了feature channel，可惜效果不佳，网络时常陷入不均衡的状态（即D网络很强大，G网络不能与之抗衡），于是只好妥协，生成128X128的图片，进行了32轮训练，以下是效果：</p><p><img src="/images/2021/%E8%80%81%E5%A9%86%E4%B8%8D%E5%A4%9FD%EF%BC%9F%E9%82%A3%E5%B0%B1%E8%87%AA%E5%B7%B1%E9%80%A0%EF%BC%81/fake_samples_epoch_031.png" alt="ours result"></p><p>当然我们的研究还未停止！分析我失败的原因，主要在于：数据量不够、高分辨率图片生成需要更深的网络、训练轮数不够、学习率等超参调节等多种原因。进一步提升分辨率的方法，可能在于加深网络层数，使用残差网络、数据增强等方法。</p><h3 id="进一步研究"><a href="#进一步研究" class="headerlink" title="进一步研究"></a>进一步研究</h3><p>真阿宅怎能满足于浅尝辄止？还有更广阔的世界等着我们去探索！</p><p>首先比较好的方向在于：生成的老婆完全取决于这个隐向量，而这个隐向量的具体维度没有意义（是多语义严重耦合、且与训练过程相关的），我们如何控制生成老婆的各种属性（如发色、瞳色、眼镜等等）以满足我们的XP系统呢？Conditional GAN应运而生。</p><p><img src="/images/2021/%E8%80%81%E5%A9%86%E4%B8%8D%E5%A4%9FD%EF%BC%9F%E9%82%A3%E5%B0%B1%E8%87%AA%E5%B7%B1%E9%80%A0%EF%BC%81/white.png" alt="只想要白毛？"></p><p>cGAN的目标在于，在G网络的输入中加入一个属性向量c，能够生成对应的图片，当然也需要在训练中对不同的真实样本进行标注，使D网络获取属性向量c的意义，并进行判别，从而使G网络也能学到这层意义。这个向量可以是multi hot的，也可以是数值的，网络甚至可以学到中间值的意义，见下图：</p><p><img src="/images/2021/%E8%80%81%E5%A9%86%E4%B8%8D%E5%A4%9FD%EF%BC%9F%E9%82%A3%E5%B0%B1%E8%87%AA%E5%B7%B1%E9%80%A0%EF%BC%81/fade.png" alt="渐变发色与嘴巴张开程度"></p><p>同时StyleGAN提出了风格（Style）这一理论，认为不同分布的两组数据也具有共同的特征，也就是风格，可以用隐向量来表示，并提出了新的Project方法，能够将一种分布的风格进行投影，到另一种分布，这就是所谓风格迁移。使用风格迁移，我们就能完成AI换脸、AI脱衣等任务了，是不是很神奇！</p><p><img src="/images/2021/%E8%80%81%E5%A9%86%E4%B8%8D%E5%A4%9FD%EF%BC%9F%E9%82%A3%E5%B0%B1%E8%87%AA%E5%B7%B1%E9%80%A0%EF%BC%81/style.png" alt="风格迁移"></p><p>GAN的使用领域绝不仅限于此，无论是图像生成，还是超分辨率，甚至是图像填补，都有GAN的身影！</p><blockquote><p>在2019年，生成对抗网络成功地模拟了暗物质在太空中特定方向的分布，并预测将要发生的引力透镜。</p></blockquote><p>由于GAN的异军突起，很多人认为画师等行业中将没落，但是我始终认为，GAN虽然能创造出从未存在过的事物，但也是网络对作品进行学习而得来的，不能叫做真正意义上的创作，比不上人类的创作灵魂。<strong>画师、作曲家等创作者仍有着无可替代的地位，创作者万岁！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;神经网络真是个神奇的东西，它既能识别图像中的物品属于哪一种类，又能定位视频中目标，甚至能够听懂人类的语言，简直就是无所不能！可你是否想过，神经网络甚至能够进行创作，能够生成世界上根本不存在的东西呢？&lt;/p&gt;
&lt;h3 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; cla</summary>
      
    
    
    
    <category term="开发" scheme="http://starydy.xyz/categories/%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>C++常用数据结构使用方法</title>
    <link href="http://starydy.xyz/2021/04/15/C++%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://starydy.xyz/2021/04/15/C++%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2021-04-15T14:38:00.000Z</published>
    <updated>2023-09-14T12:11:58.192Z</updated>
    
    <content type="html"><![CDATA[<p>最近为了找实习，简单地复习了一下C++常用的数据结构，在此做个笔记。</p><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector<typeA></h2><p>首先是最常见的vector，和数组很类似，可以使用索引进行读写操作。</p><p>常用方法：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">myvector(size, a)</span><br><span class="line">resize(size)</span><br><span class="line">reserve(spacesize)</span><br><span class="line">push_back(a)</span><br><span class="line">pop_back()</span><br><span class="line">myvector[i]</span><br><span class="line">size()</span><br><span class="line">clear()</span><br><span class="line">empty()</span><br><span class="line">reverse(myvector.begin(), myvector.end())</span><br><span class="line">sort(myvector.begin(), myvector.end())</span><br></pre></td></tr></table></figure><br>迭代器使用begin()、end()进行正向遍历，由于不支持减一操作，使用rbegin()、rend()进行反向遍历，其他数据结构都类似。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list<typeA></h2><p>实现了链表的结构，不同于vector，在进行插入删除操作时效率很高，但是在进行随机读取时效率较低。</p><p>常用方法：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mylist(size, a)</span><br><span class="line">push_back(a)</span><br><span class="line">push_front(a)</span><br><span class="line">pop_back()</span><br><span class="line">pop_front()</span><br><span class="line">back()</span><br><span class="line">front()</span><br><span class="line">size()</span><br><span class="line">clear()</span><br><span class="line">empty()</span><br><span class="line">insert(it, num)</span><br><span class="line">erase(it, num)</span><br></pre></td></tr></table></figure></p><h2 id="set-unordered-set"><a href="#set-unordered-set" class="headerlink" title="set, unordered_set"></a>set<typeA>, unordered_set<typeA></h2><p>使用红黑树实现的set，主要用于保留一系列<strong>不重复</strong>的值，并且进行了排序，查找具有O(logn)的复杂度。<br>使用哈希表实现的unordered_set，基本方法与set相同，但是不具备顺序，查找具有O(1)的复杂度。</p><p>常用方法：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">insert(a)</span><br><span class="line">erase(a)</span><br><span class="line">count()&#x2F;&#x2F;可以用来查找值是否存在</span><br><span class="line">find()&#x2F;&#x2F;同样用于查找是否存在，但是使用的是迭代器，通常语法为：set.find(x) !&#x3D; end，若为真，则代表存在x。</span><br><span class="line">size()</span><br><span class="line">clear()</span><br><span class="line">empty()</span><br><span class="line">&#x2F;&#x2F;遍历使用iterator实现：</span><br><span class="line">set&lt;typeA&gt;::iterator it &#x3D; myset.begin();</span><br><span class="line">while(it !&#x3D; myset.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; \*it &lt;&lt; endl;</span><br><span class="line">it++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="map-lt-typeA-typeB-gt-unordered-map-lt-typeA-typeB-gt"><a href="#map-lt-typeA-typeB-gt-unordered-map-lt-typeA-typeB-gt" class="headerlink" title="map&lt;typeA, typeB&gt;, unordered_map&lt;typeA, typeB&gt;"></a>map&lt;typeA, typeB&gt;, unordered_map&lt;typeA, typeB&gt;</h2><p>使用红黑树实现的map，主要用于保留一系列<strong>不重复</strong>的键值对，即可以使用键进行索引，并且对键进行了排序，查找具有O(logn)的复杂度。<br>使用哈希表实现的unordered_map，基本方法与map相同，但是不具备顺序，查找具有O(1)的复杂度。</p><p>常用方法：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">insert(make_pair(key, value))</span><br><span class="line">erase()</span><br><span class="line">mymap[key]&#x2F;&#x2F;使用key作为索引进行读写map的 操作</span><br><span class="line">count()&#x2F;&#x2F;可以用来查找值是否存在</span><br><span class="line">find()&#x2F;&#x2F;同样用于查找是否存在，但是使用的是迭代器，通常语法为：map.find(x) !&#x3D; end，若为真，则代表存在x</span><br><span class="line">size()</span><br><span class="line">clear()</span><br><span class="line">empty()</span><br><span class="line">&#x2F;&#x2F;遍历使用iterator实现：</span><br><span class="line">map&lt;typeA&gt;::iterator it &#x3D; mymap.begin();</span><br><span class="line">while(it !&#x3D; mymap.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">it++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack<typeA></h2><p>最常见的栈结构，一种先入后出的结构，但是不具有迭代器，主要用于存储某些状态的特定元素使用。</p><p>常用方法：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push(a)</span><br><span class="line">pop()</span><br><span class="line">top()</span><br><span class="line">size()</span><br><span class="line">empty()</span><br><span class="line">&#x2F;&#x2F;由于没有迭代器，所以不能进行遍历，唯一方法是遍历容器内容，并移除访问过的每一个元素</span><br></pre></td></tr></table></figure></p><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue<typeA></h2><p>最常见的队列结构，一种先入先出的结构，但是不具有迭代器，主要用于某种状态下待处理元素的记录，常见于BFS算法中。</p><p>常用方法：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push(a)</span><br><span class="line">pop()</span><br><span class="line">front()</span><br><span class="line">back()</span><br><span class="line">size()</span><br><span class="line">empty()</span><br><span class="line">&#x2F;&#x2F;与stack一样没有迭代器，所以不能进行遍历，唯一方法是遍历容器内容，并移除访问过的每一个元素</span><br></pre></td></tr></table></figure></p><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque<typeA></h2><p>与queue相似的双向队列结构，能够进行首尾的读取，加入与弹出，拥有迭代器。</p><p>常用方法：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push_back(a)</span><br><span class="line">pop_back()</span><br><span class="line">push_front(a)</span><br><span class="line">pop_front()</span><br><span class="line">back()</span><br><span class="line">front()</span><br><span class="line">at(i)等价于[i]</span><br><span class="line">size()</span><br><span class="line">clear()</span><br><span class="line">empty()</span><br></pre></td></tr></table></figure></p><h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p>实际上C++并没有堆这个类，使用的是对另一个数据结构的迭代器进行建堆操作来创建一个堆。<br>堆使用完全二叉树实现的，大根堆即代表根节点大于（或等于）叶子节点，小根堆同理。堆方便指出就在于便于进行排序（处在堆顶的一定是最大值）。</p><p>常用方法：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;typeA&gt; myvector;</span><br><span class="line">make_heap(myvector.begin(), myvector.end());&#x2F;&#x2F;默认为大根堆</span><br><span class="line">make_heap(myvector.begin(), myvector.end(), greater&lt;type&gt;);&#x2F;&#x2F;创建小根堆，创建堆会改变原始数据结构的顺序为堆树的层次遍历</span><br><span class="line">myvector.push_back(a);</span><br><span class="line">push_heap(myvector.begin(), myvector.end());&#x2F;&#x2F;push操作先对原数据进行</span><br><span class="line">pop_heap(myvector.begin(), myvector.end());&#x2F;&#x2F;pop操作先对堆进行</span><br><span class="line">myvector.pop_back(a);</span><br><span class="line">sort_heap(myvector.begin(), myvector.end());&#x2F;&#x2F;核心操作，进行堆排序（大根堆进行升序排序，小根堆进行降序排序）</span><br></pre></td></tr></table></figure></p><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p>C++没有堆，但是我们还可以通过priority_queue来实现有排序功能的数据结构，当然，内部结构还是堆的原理。<br>priority_queue的方法与上面的队列queue基本相同，只不过在我们把新元素入队时，会自动更新这个堆，使得我们每次出队的元素都是当前队列最大/最小的。</p><p>常用方法：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; up;&#x2F;&#x2F;升序队列（小根堆）</span><br><span class="line">priority_queue &lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; down;&#x2F;&#x2F;降序队列（大根堆）</span><br><span class="line">push(a)</span><br><span class="line">pop()</span><br><span class="line">front()</span><br><span class="line">back()</span><br><span class="line">size()</span><br><span class="line">empty()</span><br></pre></td></tr></table></figure></p><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>不同于C语言中使用char*或char[]来维护字符串，C++使用string类进行字符串的操作，其中之前C语言对于char*字符串的操作方法大多数也适用于string类型。</p><p>常用方法：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mystring(&quot;Hello&quot;)</span><br><span class="line">mystring(size, &#39;A&#39;)&#x2F;&#x2F;注意C++中 &#39;A&#39;表示一个字符（char），&quot;A&quot;表示一个字符串（char\*）</span><br><span class="line">char* mychar &#x3D; &quot;Hello&quot;;&#x2F;&#x2F;char* 与 string的转换：</span><br><span class="line">mystring &#x3D; mychar;</span><br><span class="line">mychar &#x3D; mystring.c_str();</span><br><span class="line">mystring &#x3D; mystring1 + mystring2;&#x2F;&#x2F;字符串的拼接：</span><br><span class="line">mystring.append(mystring1);</span><br><span class="line">substring &#x3D; mystring.substr(start, size);&#x2F;&#x2F;提取、插入、删除、替换子串：</span><br><span class="line">newstring &#x3D; mystring.insert(start, substring);</span><br><span class="line">mystring.erase(start, size);</span><br><span class="line">mystring.replace(start, size, substring);</span><br><span class="line">char mychar &#x3D; mystring[i];&#x2F;&#x2F;索引读写：</span><br><span class="line">&#x2F;&#x2F;与其他STL数据结构类似，也可以使用迭代器进行string的操作。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近为了找实习，简单地复习了一下C++常用的数据结构，在此做个笔记。&lt;/p&gt;
&lt;h2 id=&quot;vector&quot;&gt;&lt;a href=&quot;#vector&quot; class=&quot;headerlink&quot; title=&quot;vector&quot;&gt;&lt;/a&gt;vector&lt;typeA&gt;&lt;/h2&gt;&lt;p&gt;首先是最常</summary>
      
    
    
    
    <category term="开发" scheme="http://starydy.xyz/categories/%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>开启新的旅程！</title>
    <link href="http://starydy.xyz/2020/12/14/%E5%BC%80%E5%90%AF%E6%96%B0%E7%9A%84%E6%97%85%E7%A8%8B%EF%BC%81/"/>
    <id>http://starydy.xyz/2020/12/14/%E5%BC%80%E5%90%AF%E6%96%B0%E7%9A%84%E6%97%85%E7%A8%8B%EF%BC%81/</id>
    <published>2020-12-14T09:33:41.000Z</published>
    <updated>2020-12-14T12:21:38.765Z</updated>
    
    <content type="html"><![CDATA[<p>转眼间，从我搭建第一个博客已经过去了一年，服务器到期，现在将博客转移到了github下进行托管，在此对对本博客做出贡献的大家说声谢谢！，现在本博客失去了投稿功能，但是我们还是能在评论区相见！域名我会续费，还请大家持续关注starydy.xyz，关注Star Blog！</p><p>谢谢大家！</p><p><img src="/images/2020/%E5%BC%80%E5%90%AF%E6%96%B0%E7%9A%84%E6%97%85%E7%A8%8B/thanku.png" alt="thanku"></p><p>以下是测试！</p><div class="alert alert-success">成功啦o(*￣▽￣*)ブ</div><div class="alert alert-danger">有危险Σ(っ °Д °;)っ</div><div class="alert alert-info">有消息(・∀・(・∀・(・∀・*)</div><div class="alert alert-warning">当心哦≧ ﹏ ≦</div><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>折叠框的标题</span></div>    <div class="xContent"><div class="inner">        <p>被折叠的内容 1<br>被折叠的内容 2</p>     </div></div>    </div><div class="panel panel-TYPE">    <div class="panel-title">面板框的标题</div>    <div class="panel-body">        <p>面板里的内容 1<br>面板里的内容 2</p>    </div>    </div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codes</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转眼间，从我搭建第一个博客已经过去了一年，服务器到期，现在将博客转移到了github下进行托管，在此对对本博客做出贡献的大家说声谢谢！，现在本博客失去了投稿功能，但是我们还是能在评论区相见！域名我会续费，还请大家持续关注starydy.xyz，关注Star Blog！&lt;/p</summary>
      
    
    
    
    <category term="日常" scheme="http://starydy.xyz/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>毕设开坑，欢迎大家关注</title>
    <link href="http://starydy.xyz/2020/11/28/%E6%AF%95%E8%AE%BE%E5%BC%80%E5%9D%91%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E5%85%B3%E6%B3%A8/"/>
    <id>http://starydy.xyz/2020/11/28/%E6%AF%95%E8%AE%BE%E5%BC%80%E5%9D%91%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E5%85%B3%E6%B3%A8/</id>
    <published>2020-11-28T23:14:00.000Z</published>
    <updated>2023-09-14T12:11:58.196Z</updated>
    
    <content type="html"><![CDATA[<p>好久没更新，这次开了毕设坑，欢迎大家关注我的github项目：<br><a href="https://github.com/StarRealMan/SSVIO">SSVIO</a><br><img src="/old_images/2020/11/1735837242.png" alt="2020-11-29 15-12-45 的屏幕截图.png"></p><p>目前的进度：<br><img src="/old_images/2020/11/imu.jpg" alt="imu.jpg"><br><img src="/old_images/2020/11/platform.jpg" alt="platform.jpg"><br><img src="/old_images/2020/11/recon.png" alt="recon.png"><br><img src="/old_images/2020/11/reconstruction.png" alt="reconstruction.png"><br><img src="/old_images/2020/11/niao.png" alt="niao.png"><br><img src="/old_images/2020/11/running.png" alt="running.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久没更新，这次开了毕设坑，欢迎大家关注我的github项目：&lt;br&gt;&lt;a href=&quot;https://github.com/StarRealMan/SSVIO&quot;&gt;SSVIO&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/old_images/2020/11/1735837242.p</summary>
      
    
    
    
    <category term="日常" scheme="http://starydy.xyz/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>从支持向量机到拉格朗日乘子对偶问题</title>
    <link href="http://starydy.xyz/2020/09/17/%E4%BB%8E%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%88%B0%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://starydy.xyz/2020/09/17/%E4%BB%8E%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%88%B0%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98/</id>
    <published>2020-09-17T19:11:00.000Z</published>
    <updated>2020-12-14T12:39:06.365Z</updated>
    
    <content type="html"><![CDATA[<p>很早以前就在林哥那儿听过支持向量机这个神奇的名字，是用来识别（分类）装甲板数字的，当时觉得很高深，很硬核。<br>最近在研读周志华老师所著的《机器学习》，又看到了这个熟悉而又陌生的名词——支持向量机。这次终于能够更深入地了解它了。写此文章来记录。</p><h2 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h2><p>首先考虑一个二分类问题，我们有一组有标记的样本，分布在样本空间中，假设是一个二维的样本空间，那么它们看起来可能是这样的：<br><img src="/old_images/2020/10/3898272400.jpg" alt="2019-04-29-134021.jpg"><br>其中我们可以认为三角代表正类而圆圈代表反类。<br>怎样找到一条直线能够最大程度上地区分正类和反类呢？很容易想到我们需要一条直线（超平面），使它的一侧全是正类，另一侧全是反类。这种情况叫做线性可分的情况，等一会儿我们会讨论基本线性可分与非线性情况。<br><img src="/old_images/2020/10/3032572949.png" alt="1.1.png"><br>不过这样的直线（超平面）有很多，哪一条更好呢？这里的更好代表着对于新来的样本也能有很好的划分能力，所以我们启发式地想，找一条能够划分样本，并且两边样本到直线最近距离最大且相等的直线。<br><img src="/old_images/2020/10/4055019828.png" alt="2.1.png"><br>这些据直线最近的样本的位置（向量）就叫做支持向量。<br>用更严谨的数学表示就是：<br><img src="/old_images/2020/10/1161417211.jpg" alt="Snipaste_2020-10-05_21-09-28.jpg"><br><img src="/old_images/2020/10/513067831.jpg" alt="Snipaste_2020-10-05_21-09-43.jpg"><br>不要忘记我们能够划分样本的条件：<br><img src="/old_images/2020/10/2013533644.jpg" alt="Snipaste_2020-10-05_21-09-17.jpg"><br>细心的我们可以发现，我们定义的这个直线理应具有dim(w)个自由度，而实际上却有dim(w)+1个参数（别忘了截距b），我们很容易想到，同时放大缩小w与b，直线是不变的，但是对于直线wx+b=1，却是在变化的，因此我们仅仅优化|w|²看似不合理，实际上整条直线已经在条件中进行了限制，所以b也会被考虑进去的。</p><p>于是我们使用支持向量机把二分类模型训练问题转化为了一个带不等式约束的优化问题。<br>我们知道对于等式约束的优化问题我们可以用拉格朗日乘子法进行解决，但是对于不等式约束，我们又该怎样解决呢？<br>我们称这个优化问题为原始问题，解决办法就是使用拉格朗日乘子法找到一个对偶问题，解决对偶问题并且在满足KKT条件的情况下，我们就能解决原始问题。<br>那么具体怎么做呢？<br>首先还是使用拉格朗日乘子法，找到拉格朗日函数：<br><img src="/old_images/2020/10/3422282407.jpg" alt="Snipaste_2020-10-05_21-27-07.jpg"><br>为了把不等式约束消解掉，我们分情况讨论：<br>如果求得的直线不满足不等式约束，则L取得max只需要α-&gt;∞，就有：<br><img src="/old_images/2020/10/2634073253.jpg" alt="Snipaste_2020-10-05_21-28-01.jpg"><br>如果满足不等式约束，则有L取得max发生在α=0的情况下，即：<br><img src="/old_images/2020/10/1816268613.jpg" alt="Snipaste_2020-10-05_21-28-08.jpg"><br>所以我们把不等式约束的优化问题化为双重最值的优化问题：<br><img src="/old_images/2020/10/2296969013.jpg" alt="Snipaste_2020-10-05_21-28-13.jpg"><br>根据对偶原理，它的对偶问题为：<br><img src="/old_images/2020/10/270394888.jpg" alt="Snipaste_2020-10-05_21-34-33.jpg"><br>同时还要满足KKT条件：<br><img src="/old_images/2020/10/2604642185.jpg" alt="Snipaste_2020-10-05_21-35-19.jpg"><br>解得最终的超平面为：（具体方法略）<br><img src="/old_images/2020/10/1506103335.jpg" alt="Snipaste_2020-10-05_21-35-19.jpg"><br>我们还得到一个结论，就是最终发挥作用的样本点只有支持向量，这点我们也能直观地感受到。</p><h2 id="还有一些没解决的问题"><a href="#还有一些没解决的问题" class="headerlink" title="还有一些没解决的问题"></a>还有一些没解决的问题</h2><p>上面一节我们只讨论了线性可分的情况，如果遇到基本上线性可分的情况（有有限个点被分错），或者非线性可分的情况<br><img src="/old_images/2020/10/1768418527.jpg" alt="2019-03-08-010339.jpg"><br>我们该怎么办呢？</p><p>1.软间隔法<br>对于基本上线性可分的情况，我们可以改进优化参数，使其允许一些错误出现，但是要尽最大可能避免这些错误，比如这样：<br><img src="/old_images/2020/10/2773680925.jpg" alt="Snipaste_2020-10-05_21-41-57.jpg"><br>在优化函数中引入惩罚项，惩罚那些超过界限的样本点。<br>2.核方法<br>对于非线性的方法，软间隔就不能用了，比如这种情况：<br><img src="/old_images/2020/10/2447629851.jpg" alt="Snipaste_2020-10-05_21-44-07.jpg"><br>但是我们可以使用一个映射将样本转换到另一个空间中<br><img src="/old_images/2020/10/2420399875.jpg" alt="Snipaste_2020-10-05_21-45-04.jpg"><br><img src="/old_images/2020/10/3031661130.png" alt="下载.png"><br>这样就能解决非线性可分的问题了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很早以前就在林哥那儿听过支持向量机这个神奇的名字，是用来识别（分类）装甲板数字的，当时觉得很高深，很硬核。&lt;br&gt;最近在研读周志华老师所著的《机器学习》，又看到了这个熟悉而又陌生的名词——支持向量机。这次终于能够更深入地了解它了。写此文章来记录。&lt;/p&gt;
&lt;h2 id=&quot;支</summary>
      
    
    
    
    <category term="控制" scheme="http://starydy.xyz/categories/%E6%8E%A7%E5%88%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>第二次硬件尝试之开关电源</title>
    <link href="http://starydy.xyz/2020/09/12/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E7%A1%AC%E4%BB%B6%E5%B0%9D%E8%AF%95%E4%B9%8B%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90/"/>
    <id>http://starydy.xyz/2020/09/12/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E7%A1%AC%E4%BB%B6%E5%B0%9D%E8%AF%95%E4%B9%8B%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90/</id>
    <published>2020-09-12T19:45:00.000Z</published>
    <updated>2020-12-14T12:20:57.326Z</updated>
    
    <content type="html"><![CDATA[<p>为了能使树莓派脱离有线的束缚，我这次就做一个简单的锂电池充放电电路来练练手(●ˇ∀ˇ●)<br>（第一次做了更为简单的STM32-UARTHUB）<br>电源芯片选择的是珠海智融科技有限公司的SW6124，SW6124是一款高度集成的电源管理IC，适用于快速充电移动电源应用。 它集成了4A开关充电器，18W同步升压，PD / QC / FCP / PE / SFCP快速充电协议，电量计和电源控制器。 SW6124借助简单的外部组件，为快速充电电池管理提供了交钥匙的高效解决方案。</p><p>手册最后给出了电池管理充放电应用电路图：<br><img src="/old_images/2020/09/2522050574.jpg" alt="Snipaste_2020-09-13_15-05-50.jpg"><br>已经比较符合我们的需求了，我们在其之上稍作更改，去掉了USB-A和Micro USB的接口，仅保留USB Type-C接口。并且使用一个单刀双置开关切换USB供电与电池供电。<br>原理很简单，在插入USB TypeC时，使用开关将5V输出直接与TypeC电源连接，直接向树莓派供电，与此同时，TypeC电源也向电池充电。在未插入USB时，使5V输出与Boost电路输出端相连接，使用电池进行供电。<br>画出原理图：<br><img src="/old_images/2020/09/1356202506.jpg" alt="Snipaste_2020-09-13_15-10-15.jpg"><br>TypeC接口部分；<br><img src="/old_images/2020/09/2234319971.jpg" alt="Snipaste_2020-09-13_15-10-54.jpg"><br>开关，树莓派插针部分；<br><img src="/old_images/2020/09/2393108645.jpg" alt="Snipaste_2020-09-13_15-11-29.jpg"><br>芯片电量显示部分；<br><img src="/old_images/2020/09/2995037215.jpg" alt="Snipaste_2020-09-13_15-11-48.jpg"><br>芯片Boost电路（3.7V-&gt;5V）及控制部分。<br>这个电路最重要的部分就是开关电源部分，好在SW6124集成了开关管以及控制电路，我们只需要外加一个电感就能实现Boost升压的功能。</p><p>最后就是PCB绘制：<br>首先进行布局布线。简单的PCB布局可以按照原理图的分布进行，并且要合理设计接口位置，注意芯片手册上的说明和注意事项。布线过程中注意根据线所流经的电流大小调整线的粗细，上层下层横纵交错，GND网络使用覆铜进行连接。<br><img src="/old_images/2020/09/2369037501.jpg" alt="Snipaste_2020-09-13_15-23-20.jpg"></p><p>接下来是覆铜。对于信号要求较高的板子，最好分离信号地与电源地，并且在覆铜结束后检查是否留有未接通的GND网络，进行微调（比如打过孔）。<br>最终一个简单的锂电池充放电电路板就绘制完成了，接下来就是焊接和调试啦！<br><img src="/old_images/2020/09/1988211125.jpg" alt="Snipaste_2020-09-13_15-27-03.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了能使树莓派脱离有线的束缚，我这次就做一个简单的锂电池充放电电路来练练手(●ˇ∀ˇ●)&lt;br&gt;（第一次做了更为简单的STM32-UARTHUB）&lt;br&gt;电源芯片选择的是珠海智融科技有限公司的SW6124，SW6124是一款高度集成的电源管理IC，适用于快速充电移动电源应用</summary>
      
    
    
    
    <category term="开发" scheme="http://starydy.xyz/categories/%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>ROS入门</title>
    <link href="http://starydy.xyz/2020/08/28/ROS%E5%85%A5%E9%97%A8/"/>
    <id>http://starydy.xyz/2020/08/28/ROS%E5%85%A5%E9%97%A8/</id>
    <published>2020-08-28T06:08:00.000Z</published>
    <updated>2020-12-14T12:20:30.530Z</updated>
    
    <content type="html"><![CDATA[<p>进入大四，终于要开启我的ROS之旅。<br>接触了几天ROS，越发发觉它的便利，今天来记录一下最基础的ROS操作。（大部分来自<a href="https://www.ros.org/">ROS官网</a>，俗话说官网是学习的最佳路径）</p><h2 id="ROS项目管理机制"><a href="#ROS项目管理机制" class="headerlink" title="ROS项目管理机制"></a>ROS项目管理机制</h2><p>ROS使用Workspace+Package的方式来管理一个项目。比如以一个机器人为例，机器人的每一个功能（比如传感器数据接收，运动控制，导航感知，决策）都会对应一个Package，这些Package之间可能互相依赖，他们共同构成一个Workspace，就构成了这个机器人整体。<br>从零开始构建一个项目，首先需要构建一个Workspace，使用：</p><pre><code>$ mkdir -p ~/catkin_ws/src        #用来存放Package$ cd ~/catkin_ws/$ catkin_make</code></pre><p>在家目录构建一个空的，名为catkin_ws的Workspace，使用<strong>catkin_make</strong>可以自动生成一些所需的配置文件和目录（这个命令也充当着ROS管理工程中CMake的作用）。<br>如果想让ROS命令认识这个包，需要把他的位置加入到环境变量中去，这时我们就需要使用source（用来执行命令行脚本）执行～/catkin_ws/devel/中的 setup.bash命令了。这时$ROS_PACKAGE_PATH变量就包含了我们的工作区/src/目录。<br>如果想要使用官方的一些Package，他们的初始化脚本是/opt/ros/<distri>/setup.bash。（也可将其放入~/.bashrc中，在启动终端后自动执行）<br>对ROS的Package的一些操作：</p><pre><code>$ rospack find [package_name]$ roscd [locationname[/subdir]]$ roscd log$ rosls [locationname[/subdir]]</code></pre><p>如何创建一个Package？<br>一个Package由一个独立的文件夹内的package.xml和一个CMakeists.txt文件（以及其他必要文件）组成，如下所示：</p><pre><code>workspace_folder/        -- WORKSPACE  src/                   -- SOURCE SPACE    CMakeLists.txt       -- &#39;Toplevel&#39; CMake file, provided by catkin    package_1/      CMakeLists.txt     -- CMakeLists.txt file for package_1      package.xml        -- Package manifest for package_1    ...    package_n/      CMakeLists.txt     -- CMakeLists.txt file for package_n      package.xml        -- Package manifest for package_n</code></pre><p>如何自动创建这些文件？在~/catkin_ws/src目录中使用</p><pre><code>$ catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] [depend3]</code></pre><p>创建一个依赖于dependx的Package。<br>使用</p><pre><code>$ catkin_make$ . ~/catkin_ws/devel/setup.bash</code></pre><p>build这个Workspace（内的所有Package），并且将其（内的所有Package）加入环境变量。</p><p>这些Package都有着各自（直接）依赖的Package，catkin_create_pkg命令中的dependx会体现在package.xml中。<br>直接的依赖Package使用以下命令查看：<br>$ rospack depend1 [Package name]<br>间接的依赖Package使用以下命令查看：<br>$ rospack depends [Package name]<br>对于你自己的项目，可以通过修改package.xml和CMakeLists.txt来进行定制化的操作。（详细略）</p><p>就如同CMake管理的项目一样，ROS管理的项目使用catkin_make进行项目的编译构建。<br>在～/catkin_ws/中使用：</p><pre><code>$ catkin_make$ catkin_make install  # (optionally)</code></pre><p>这个命令会build整个Workspace下的所有Package，与cmake命令有相同作用。</p><h2 id="ROS通信机制-1"><a href="#ROS通信机制-1" class="headerlink" title="ROS通信机制 1##"></a>ROS通信机制 1##</h2><p>ROS不仅为我们提供了一种项目管理的功能，还提供了一种便利的多进程通讯机制。<br>要启用这个多进程通讯机制，首先我们要启动ROS内核，使用：</p><pre><code>$ roscore</code></pre><p>这个roscore进程是ROS进程间通讯的核心，起到了中继站的作用。一切ROS应用都少不了它。<br>ROS中，node代表一个可以进行通讯的节点，使用以下命令查看node属性：</p><pre><code>$ rosnode list$ rosnode info /[node name]$ rosnode ping /[node name]</code></pre><p>使用rosrun来运行一个Package中的node。</p><pre><code>$ rosrun [package_name] [node_name]$ rosrun turtlesim turtlesim_node __name:=my_turtle</code></pre><p>node之间通讯是通过node-msg-topic机制，两个或多个node向同一个topic发送消息msg，并接收其他node的特定的消息msg，就能实现通讯。<br>使用以下命令可以图形化查看当前运行中的node和topic：</p><pre><code>$ rosrun rqt_graph rqt_graph</code></pre><p>为了查看运行中topic中传递的数据和一些其他信息，使用：</p><pre><code>$ rostopic echo [topic]$ rostopic list -h$ rostopic list -v$ rostopic type [topic]$ rosmsg show [msg type]$ rostopic hz$ rosrun rqt_plot rqt_plot</code></pre><p>手动上传msg到指定的topic，使用：</p><pre><code>$ rostopic pub [topic] [msg_type] [args]</code></pre><p>（注意，我们在命令行中使用的一些命令也是通过创建节点来实现功能的）</p><h2 id="ROS通信机制-2"><a href="#ROS通信机制-2" class="headerlink" title="ROS通信机制 2##"></a>ROS通信机制 2##</h2><p>除了node-msg-topic的通信方式，我们还可以通过service实现通信。<br>rosservice的基本使用方法：</p><pre><code>$ rosservice list         print information about active services$ rosservice call         call the service with the provided args$ rosservice type         print service type$ rosservice find         find services by service type$ rosservice uri          print service ROSRPC uri</code></pre><p>总而言之，每个Package会包含一些service，使用rosservice call可以调用这些service（可以理解为调用方法），实现某些功能。</p><p>使用rosparam可以存储某个Package参数，调整Package的功能：</p><pre><code>$ rosparam set            set parameter$ rosparam get            get parameter$ rosparam load           load parameters from file$ rosparam dump           dump parameters to file$ rosparam delete         delete parameter$ rosparam list           list parameter names</code></pre><p>使用图形化界面管理ROS，使用如下命令：</p><pre><code>$ rosrun rqt_console rqt_console$ rosrun rqt_logger_level rqt_logger_level</code></pre><p>使用.launch文件一键启动整个项目：</p><pre><code>$ roslaunch [package] [filename.launch]&lt;launch&gt;  &lt;group ns=&quot;turtlesim1&quot;&gt;    &lt;node pkg=&quot;turtlesim&quot; name=&quot;sim&quot; type=&quot;turtlesim_node&quot;/&gt;  &lt;/group&gt;  &lt;group ns=&quot;turtlesim2&quot;&gt;    &lt;node pkg=&quot;turtlesim&quot; name=&quot;sim&quot; type=&quot;turtlesim_node&quot;/&gt;  &lt;/group&gt;  &lt;node pkg=&quot;turtlesim&quot; name=&quot;mimic&quot; type=&quot;mimic&quot;&gt;    &lt;remap from=&quot;input&quot; to=&quot;turtlesim1/turtle1&quot;/&gt;    &lt;remap from=&quot;output&quot; to=&quot;turtlesim2/turtle1&quot;/&gt;  &lt;/node&gt;&lt;/launch&gt;</code></pre><p>使用rosed进行编辑：</p><pre><code>$ rosed [package_name] [filename]</code></pre><p>创建Package_dir/msg/Num.msg文件，来规定传递的msg。<br>创建Package_dir/srv/AddTwoInts.srv文件，来规定service的类型。<br>（需要在package.xml和CMakeists.txt声明该文件）</p><pre><code>$ rosmsg show [message type]$ rosmsg -h$ rossrv show &lt;service type&gt;</code></pre><p>最后，我们可以在C++程序中使用ROS的库来实现msg和service的操作。<br>（对于我们添加的msg和srv，make后会自动生成对应的头文件，便于对其进行操作）</p><pre><code>#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;#include &quot;Package_dir/AddTwoInts.h&quot;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;进入大四，终于要开启我的ROS之旅。&lt;br&gt;接触了几天ROS，越发发觉它的便利，今天来记录一下最基础的ROS操作。（大部分来自&lt;a href=&quot;https://www.ros.org/&quot;&gt;ROS官网&lt;/a&gt;，俗话说官网是学习的最佳路径）&lt;/p&gt;
&lt;h2 id=&quot;ROS项目管</summary>
      
    
    
    
    <category term="工具" scheme="http://starydy.xyz/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>利用ANSYS进行叶轮动态流场仿真分析实例</title>
    <link href="http://starydy.xyz/2020/08/15/%E5%88%A9%E7%94%A8ANSYS%E8%BF%9B%E8%A1%8C%E5%8F%B6%E8%BD%AE%E5%8A%A8%E6%80%81%E6%B5%81%E5%9C%BA%E4%BB%BF%E7%9C%9F%E5%88%86%E6%9E%90%E5%AE%9E%E4%BE%8B/"/>
    <id>http://starydy.xyz/2020/08/15/%E5%88%A9%E7%94%A8ANSYS%E8%BF%9B%E8%A1%8C%E5%8F%B6%E8%BD%AE%E5%8A%A8%E6%80%81%E6%B5%81%E5%9C%BA%E4%BB%BF%E7%9C%9F%E5%88%86%E6%9E%90%E5%AE%9E%E4%BE%8B/</id>
    <published>2020-08-15T07:37:05.000Z</published>
    <updated>2020-12-14T12:21:46.549Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，我是Albert！没错，我又来了！最近题主正在做一个小项目，其中一个功能就是利用一个半开离心泵进行对一个有限固定水域（就是一个小泳池）进行水循环，我们都知道洗衣机滚筒就是一个典型的离心泵，所以有很大可能将离心泵开口后，里面的水有可能流不出来，或者说达不到预期参数，为了直观快速地看到整个流场情况以确定下一步迭代方向，题主选择了ANSYS中的Fluent作为仿真平台，借着这个项目正好分享一下动态仿真如何进行。下图是离心泵模型图和简化模型图（因为是几小时出的初稿，很丑）。</p><p><img src="/old_images/2020/08/615084051.png" alt="离心泵模型图.PNG"></p><p><img src="/old_images/2020/08/1060845710.png" alt="简化模型图.PNG"></p><p><strong><em>一、模型前处理及导出</em></strong></p><p>从上面两张图可以看出，简化模型主要保留了离心泵特征和开口尺寸等关键信息，这样的处理是为了减少计算量，突出问题主要矛盾。除此之外呢，可能比较注重细节的同学看到了简化模型有些许不同，在叶轮外加了一个圆柱体，这部分叫做仿真的前处理，在进行动态流场仿真的时候，流体的传递并不是像真实物理世界连续传递那样，那样的计算量过于庞大，效率很低，Fluent的解决方式是通过interface连接动域和静域，将流动流体（interior）交互到静止流体（interior）中，所以在前处理就是要建立流动域和静止域，方便后面几何处理，从简化模型中可以看出，圆柱体作为旋转域，外部的几何体为静止域，通过圆柱外表面作为interface进行交互。将简化后的模型导出为STEP格式、igs格式或Parasolid格式均可，即可进行下一步操作。</p><p><strong><em>二、ANSYS中几何处理及划分网格</em></strong></p><p>题主使用的版本是ANSYS 17.0，下一步就是打开Workbench，将Geometry模块拖入工作区然后打开Geometry后，将刚刚导出的模型文件导入Geometry中，结果就像下图所示，可能不同格式文件导入会出现一些不同，比如题主使用的是STEP格式，会导致圆柱面分离，即图中看到的圆柱壁面分成了两个面，这时候使用Tools下面的merge指令选择需要合并的面，合并一些面，做成连续面，这样处理也是为了减小运算量和避免一些玄学BUG。</p><p><img src="/old_images/2020/08/2072954433.png" alt="1.PNG"></p><p><img src="/old_images/2020/08/3016259840.png" alt="2.PNG"></p><p>基本上模型处理成这样就可以了，下一步就要建立旋转域和静止域，这里用到的是Tools下的Enclosure指令，因为我们是自己创建的几何体，所以类型选择User Defined，这里面有一个点是需要关注，以旋转域为例，所谓旋转域就是由于叶轮运动而旋转的水，所以旋转域应当是圆柱体与叶轮实体的差集，在类型选择上，User Defined Body选择圆柱体，即基本几何轮廓，Target Body选择叶轮，即内部实体，两者取差集得到流动域。如下图所示。</p><p><img src="/old_images/2020/08/3614482147.png" alt="3.PNG"></p><p><img src="/old_images/2020/08/1639294894.png" alt="4.PNG"></p><p>静止域的处理方法与旋转域相同，题主只把最后得到的效果放出来，这一步处理之后我们就可以close Geometry了，然后进入下一步了。</p><p><img src="/old_images/2020/08/4046785801.png" alt="5.PNG"></p><p>此时返回Workbench主界面，将Fluid Flow（Fluent）拖入界面连接到Geometry上，并双击打开mesh进行网格划分。这里的mesh是ANSYS自带的网格划分软件，一些基本处理是可以完成的，是基于ICEM，所以和ICEM界面一样感人。</p><p><img src="/old_images/2020/08/482966380.png" alt="6.PNG"></p><p>当我们进入mesh后，第一步在左侧结构树中先找到叶轮，将其suppress掉，方便后续处理，接下来是设置一下进出口面（inlet和outlet），目的是方便观察，还有就是气动仿真中会用到计算起点，对于液体来说就是方便观察。第二步是最关键的，即在旋转域中建立动力交互面interface，我们先把刚刚得到的旋转域独立出来（即将其余body隐藏掉），将光标选择换为Box Select。</p><p><img src="/old_images/2020/08/1083781610.png" alt="7.PNG"></p><p>然后长按鼠标左键框选旋转域中的叶轮表面，记住此时的叶轮形状并不属于叶轮实体，而是旋转域的内壁表面，然后右键绿色区域，并Create Named Selection，这样导入Fluent就可以自动生成interface了。</p><p><img src="/old_images/2020/08/2373904712.png" alt="8.PNG"></p><p>下一步就是自动划分网格了，直接点击mesh，generate即可，因为是自动划分的网格，所以网格尺寸较大，可根据需要调整尺寸大小，在Body Sizing中调整element size。</p><p><img src="/old_images/2020/08/350215919.png" alt="9.PNG"></p><p><img src="/old_images/2020/08/1791974604.png" alt="11.PNG"></p><p> 网格划分完毕后，我们的前处理就完成了，即可进入Fluent里进行计算了。</p><p><strong><em>三、仿真计算</em></strong></p><p>我们close meshing后返回Workbench主界面，先update一下mesh文件，然后双击打开Setup，这里设置一下计算方式换为并行计算，将核数改为6，增加一个GPU，提高计算速度。</p><p><img src="/old_images/2020/08/437577698.png" alt="10.PNG"></p><p>将General设置如下图，我们这次选择的是瞬时分析，由于流体是水，一定要加上重力加速度。</p><p><img src="/old_images/2020/08/3976439614.png" alt="12.PNG"></p><p>粘性模型选择K-omega下的SST模型，在Model下的Viscous选项中选择，并在材料中，将液态水添加进流体类型中，关键步骤，设置旋转域旋转，旋转域转轴及转速，如下图所示，选择mesh motion，右侧是旋转轴方向，左侧是旋转轴相对于世界坐标系的偏移量，由于我的叶轮旋转轴与世界坐标系Y轴重合，即无需偏移，转速设置为25rad/s。</p><p><img src="/old_images/2020/08/502004202.png" alt="13.PNG"></p><p>下一步就是进行初始化，选择Hybrid Initialization，初始化后的步骤就是preview，及观察叶轮是否转动，保证我们的计算是有效的。在preview中，设置步长0.01s，先跑10步。</p><p><img src="/old_images/2020/08/4228770977.png" alt="14.PNG"></p><p>preview验证 - 知乎<br><a href="https://www.zhihu.com/zvideo/1277979482393960448">https://www.zhihu.com/zvideo/1277979482393960448</a></p><p>从preview的视频中看出，叶轮的转动是正常，我们就可以开始仿真了，由于仿真时间太长，收敛后是十分密的锯齿曲线，直接上结果，速度场变化的动画。从仿真视频中可以看出，水是可以从离心泵中流出来，但是流域不是很理想，这就需要后面慢慢改导流机构啦！（由于这个Blog添加不了视频，我就把视频放到了知乎上，后面的连接复制打开一下就能看到结果啦！）</p><p>速度场结果 - 知乎<br><a href="https://www.zhihu.com/zvideo/1277981000899616768">https://www.zhihu.com/zvideo/1277981000899616768</a></p><p>下次看个人情况更新机器人学或者SLAM十四讲的学习笔记吧！希望对你有用，bye！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家好，我是Albert！没错，我又来了！最近题主正在做一个小项目，其中一个功能就是利用一个半开离心泵进行对一个有限固定水域（就是一个小泳池）进行水循环，我们都知道洗衣机滚筒就是一个典型的离心泵，所以有很大可能将离心泵开口后，里面的水有可能流不出来，或者说达不到预期参数，为</summary>
      
    
    
    
    <category term="开发" scheme="http://starydy.xyz/categories/%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>从双网卡——到路由表</title>
    <link href="http://starydy.xyz/2020/08/13/%E4%BB%8E%E5%8F%8C%E7%BD%91%E5%8D%A1%E2%80%94%E2%80%94%E5%88%B0%E8%B7%AF%E7%94%B1%E8%A1%A8/"/>
    <id>http://starydy.xyz/2020/08/13/%E4%BB%8E%E5%8F%8C%E7%BD%91%E5%8D%A1%E2%80%94%E2%80%94%E5%88%B0%E8%B7%AF%E7%94%B1%E8%A1%A8/</id>
    <published>2020-08-13T02:18:00.000Z</published>
    <updated>2020-12-14T12:20:48.906Z</updated>
    
    <content type="html"><![CDATA[<p>现在的电脑一般都拥有双网卡，但这是否是一件好事呢？对于某些小白来说，可能并不是（比如我(●ˇ∀ˇ●)）。</p><h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>拿到刚到手的树莓派，首先要做的肯定是配环境！但是在VNC连接树莓派时遇到了问题：<br>当我使用WIFI连接树莓派时，由于带宽限制，界面很卡，影响体验。<br>当我使用有线连接树莓派时，由于有线网卡的优先级高于无线网卡，导致树莓派只能浏览内网（也就是我笔记本的网络），如果使用笔记本共享外网的话只能使用DHCP自动分配IP，这样则会导致IP变化不方便我们连接 树莓派。<br>但是我明明有一个无线网卡连接外网啊！！！怎样才能把它利用起来，成了我要解决的问题。</p><h2 id="原理探究"><a href="#原理探究" class="headerlink" title="原理探究"></a>原理探究</h2><p>找了好久，终于发现了路由表这个神奇的东西，<br><a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E8%A1%A8">百度百科</a>这样说道：<br>在计算机网络中，路由表（routing table）或称路由择域信息库（RIB, Routing Information Base），是一个存储在<strong>路由器</strong>或者<strong>联网计算机</strong>中的电子表格（文件）或类数据库。路由表存储着指向特定网络地址的路径（在有些情况下，还记录有路径的路由度量值）。路由表中含有网络周边的拓扑信息。路由表建立的主要目标是为了实现路由协议和静态路由选择。</p><p>简单来讲，路由表可以规定发往何处的信息使用哪一个路由，也就是决定要发出的信息（对于计算机）或收到的信息（对于路由器）的下一跳是哪里。</p><p>在linux中配置路由表很简单，因为它全部被集成到了route这一个指令中。<br>首先我们来看路由表长什么样。<br>拿我的服务器举例，在终端中输入（sudo）route，可以看到：<br><img src="/old_images/2020/08/75184131.jpg" alt="Snipaste_2020-08-13_17-38-05.jpg"><br>其中Destination表示目标的IP地址；<br>Gateway表示选择下一跳网关IP地址（所有跨网段传输的信息均需要通过该网段的网关传输）；<br>GenMask代表掩码，用于确定一个网段；<br>Flags是用于区分的标志位；<br>Iface是网卡设备的名称（可以使用（sudo）ifconfig来查看）；<br><img src="/old_images/2020/08/1049549032.jpg" alt="Snipaste_2020-08-13_17-44-12.jpg"><br>Flags标志位确定了一系列的路由类型，主要有以下几种：<br><strong>主机路由：</strong><br>顾名思义，主机路由表示单独指向某个特定主机（IP）的路由，所有目标为该主机的信息都发送到所设定的网关，同时也确定了用哪个网卡设备传输信息。<br>主机路由除了Flags的区别，最明显的特征就是它的Destination是一个完整的IP地址，并且它的GenMask是255.255.255.255。这说明了它的目标不是一个网络而是一个特定的主机（IP）。</p><hr><p><strong>网络路由：</strong><br>理解了主机路由 在来理解网络路由并不是很难。网络路由指向一个特定的网段，因此它的GenMask不全是 1（比如是255.255.0.0）。它的Destination中也包含0（比如192.168.0.0），0的含义就是任意，这个网段表示整个192.168.*.*的网络。<br>同理，所有目标为该网络的信息都发送到所设定的网关。</p><hr><p><strong>默认路由：</strong><br>剩下最简单的就是默认路由了，没有特殊指明的主机（IP），就发送到默认路由设定的网关。默认路由最明显的特征是它的Destination是default，GenMask是0.0.0.0（表示全部网段）。</p><p>想要改变路由表，就要使用route命令，它的基本操作如下：</p><p>添加路由：route add</p><ol><li>route add -host 192.168.1.2 dev eth0 添加设备eth0为主机路由，主机IP为192.168.1.2</li><li>route add -host 10.20.30.148 gw 10.20.30.40 添加网关10.20.30.40为主机路由</li><li>route add -net 10.20.30.40 netmask 255.255.255.248 eth0 添加网络路由，网段为255.255.255.248 </li><li>route add -net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41 同上，使用网关添加</li><li>route add -net 192.168.1.0/24 eth1 添加网络路由，使用目标IP段/MASK位数形式</li><li>route add default gw 192.168.1.1 添加默认路由</li></ol><p>删除路由：route del</p><ol><li>route del -host 192.168.1.2 dev eth0 原理同上</li><li>route del -host 10.20.30.148 gw 10.20.30.40</li><li>route del -net 10.20.30.40 netmask 255.255.255.248 eth0</li><li>route del -net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41</li><li>route del -net 192.168.1.0/24 eth1</li><li>route del default gw 192.168.1.1</li></ol><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>了解了基础知识，我们来解决一下实际问题！<br>首先删除所有默认网关：</p><pre><code># sudo route del default gw 192.168.20.1# sudo route del default gw 192.168.21.1</code></pre><p>添加eth0（有线网卡）仅进行内网访问，即仅在Destination为192.168.*.*的时候使用它。</p><pre><code># sudo route add -net 192.168.0.0 netmask 255.255.0.0 eth0（或gw 192.168.21.1）</code></pre><p>添加wlan0（无线网卡）进行全网络的访问，即在非内网情况下，使用wlan0进行访问。</p><pre><code># sudo route add default wlan0（或gw 192.168.20.1）</code></pre><p>需要注意的是，如果使用网关确定，需要设置两个网卡的 默认网关不同；<br>这样设置还有一个弊端就是在访问外网时不能使用有线网卡，可能在没有WiFi的情况下还需要切换。</p><p>这样设置下来，双网卡内外分工就大功告成了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现在的电脑一般都拥有双网卡，但这是否是一件好事呢？对于某些小白来说，可能并不是（比如我(●ˇ∀ˇ●)）。&lt;/p&gt;
&lt;h2 id=&quot;发现问题&quot;&gt;&lt;a href=&quot;#发现问题&quot; class=&quot;headerlink&quot; title=&quot;发现问题&quot;&gt;&lt;/a&gt;发现问题&lt;/h2&gt;&lt;p&gt;拿到</summary>
      
    
    
    
    <category term="网络" scheme="http://starydy.xyz/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>轨道交通领域的差速问题&amp;amp;我与轨交</title>
    <link href="http://starydy.xyz/2020/07/16/%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A%E9%A2%86%E5%9F%9F%E7%9A%84%E5%B7%AE%E9%80%9F%E9%97%AE%E9%A2%98and%E6%88%91%E4%B8%8E%E8%BD%A8%E4%BA%A4/"/>
    <id>http://starydy.xyz/2020/07/16/%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A%E9%A2%86%E5%9F%9F%E7%9A%84%E5%B7%AE%E9%80%9F%E9%97%AE%E9%A2%98and%E6%88%91%E4%B8%8E%E8%BD%A8%E4%BA%A4/</id>
    <published>2020-07-16T08:07:40.000Z</published>
    <updated>2020-12-14T12:21:06.706Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，我是那个喜欢火车的Captain。<br>有人说，一个男人不成熟的标志是可以为了一项事业英勇地死去，而一个男人成熟的标志是可以为了一项事业卑贱地活着。我可能是成熟了。在上个周末，从7月10号到13号的四天时间里，我经历了两场专业课考试，一个夏令营，外加一篇恶心的硕士毕业设计级别的论文（我正在和这个课的老师对线，祝我成功）。可喜的是，夏令营的结果还不错，优营在手，只可惜没有推免资格，不能很有底气地去跟想考的导师聊，虽然现在也有别的方向的导师要我。可能不满足和缺陷才是人生的真正形态吧。<br>今天拿到了结果其实挺高兴的，听栋宇说明天考完试打算给这个blog做个宣传，我说那我不如今晚出一篇文章，开始。<br>我是学电气的，或者说我本科是学电机的，就是那个会动的大铁疙瘩，但我今天想跟大家聊聊偏机械方面的内容。<br>我们日常生活中最常见的交通工具应该就是汽车了。无论以什么能源方式驱动，汽车在行驶过程中都会遵循相同的规律，我转动方向盘，前轮的方向就会变化带动汽车曲线运动。对于轨道交通（传统轮轨）而言，这样的过程发生在铁轨与走行部之间。<strong>走行部，理解字面即可，用于列车在铁轨上走行的部分。</strong>通俗一点讲，就是转向架。如果你不知道转向架是什么，没关系，你可以理解为是火车的车轮以及和它配套的一系列起到固定、缓冲减震、传动作用的机械系统。<br>可能很多人大概知道转向架是什么，但并没有真正地去研究过。的确，很惭愧地讲，在准备这个夏令营之前我也没有好好研究过，我关注的往往是与电有关的内容，机械部分的我一般都会很礼貌地跳过。转向架就是铁路车辆转弯的作动装置，它的上部与车厢相连接，并可以以垂直道面的方向为轴做小角度转动。<strong>注意，这里说的是“垂直道面的方向”，而不是竖直方向或者重力方向，</strong>一会儿会说为什么。一个转向架大概长这样。<br><img src="/old_images/2020/07/623017393.jpg" alt="装箱架.jpg"><br>我们可以看到它有两对车轮。同轴的一对车轮我们称之为一个“轮对”，有几个轮对就称几轴。例如，我们最常见的25系列客车，也是现在普铁最广泛使用的列车，每节车厢有两个二轴转向架，车辆本身是四轴车。有兴趣的小伙伴可以去B站等平台搜一下C64K，神华十二轴电力机车，那可是机车届的扛把子，全世界功率最大的机车，单机功率达到了14400kW。14400是什么概念呢，这么说吧，感兴趣的朋友可以去看我的上一篇投稿，CRH2A非统型两列加一起差不多也就这配置。<br>我们来简单了解一下转向架的构造。传统的转向架有一类叫做“三大件式转向架”，三大件指的是两个侧架和一个摇枕。摇枕指的就是转向架中央与车体接触的条状或盘状或长条形的机械结构，承担车体重量，同时能够像刚才说的那样转动。摇枕本身是和车体相对静止的，转动时是二者共同相对于转向架其他机构轴向转动。转向架的另一个比较重要的点就是悬挂系统，分为一系悬挂（轴箱和轮对之间）和二系悬挂（摇枕或车体与构架之间）。要命的是，我买的两本教材其中一本把一二系悬挂的定义写反了，我还先看的写错的这一本，导致我现在依旧分不清一二系悬挂，每次提到都要翻书看一眼。随着技术发展，更多的转向架也慢慢出现，在转向、减震缓冲等方面的性能有着很大的提升，像摆式列车这样的转向架也更为复杂，那就是另一回事了。<br>怎么样，听迷糊了没，如果没有咱就继续。刚才提到汽车转弯的过程。转弯势必会带来一个问题，那就是两个轮子如果保证角速度相同，则线速度也应该相同，但转弯时相同时间内外侧轮子滚过的距离显然是比内侧轮子长的，这个差不可以忽视。我们知道汽车是通过差速器解决的这个矛盾，那么火车也没有差速器或者类似差速器的装置呢？没有。道理很简单，第一，轮对两侧的轮子是同轴的，能保证绝对的角速度相同，不存在差速的条件；第二，从操作的角度讲，我个人认为差速器是一个主动作动部件，你给方向盘一个转动信号差速器才会发挥作用，而你给出转向信号是因为你希望人为地使车辆转弯。但火车不是这样，火车的导向是靠轨道对轮缘的限制实现的。如果问我轮缘是什么，这里放一张图大家自己看吧，我懒得讲。看的时候顺便也了解一下踏面是什么。<br><img src="/old_images/2020/07/2822560807.jpg" alt="TIM图片20200716235932.jpg"><br>好了，我们来讲火车转弯时发生了什么。可能大家高中学物理的时候做过这样类型的题，说火车转弯，转弯半径给你了，车辆质量给你了，速度给你了，轨道面倾角也给你了，让你求对内侧轨道的压力。当时做这题我就觉得这是纯扯，你把火车当质点系？闹呢？不过话说回来，这个模型其实很大程度上真实还原了火车过弯时候的情况。如果大家有兴趣，可以下次坐高铁动车的时候体验一下，看看过弯的时候火车是不是倾斜的（普速列车也存在这个现象，但设计速度越快的线路越明显，所以动车是最优解）。这其实是为了保护铁轨和车轮，在转弯时人为将外侧铁轨垫高，使重力的一个分量先行充当向心力（效果力），尽量不让轮缘和轨道之间发生摩擦。实际上，新建的铁路大多是无砟铁路（有砟铁路就是底下是石头子儿的铁路），对于这个垫高的高度会有很精确的控制，但既有线等有砟铁路还依赖人工修正，工人师傅会定期到转弯处，测量垫高是否符合技术手册的标准，如果不够，就用工具往外侧铁路地下推石子儿，强行垫高。很有趣其实。<br>扯远了，说回到转弯过程。这里各位应该就明白上文中我提到的并不是竖直方向而是垂直于道面了吧。到这里，还是没解决差速的问题，火车的解决思路就很巧妙，真的。如果你们仔细看上面那个图，你会发现其实踏面不是柱面，而是<strong>锥型面</strong>（不知道柱面和锥型面的小伙伴自己去补高数和线代去），越靠近轮缘半径越大。这就好办了。当火车进入弯道，铁轨开始倾斜，于是车厢向一侧倾斜，重力分量充当向心力带着车厢开始画圆。由于离心效果，车辆整体会有向外侧移动的趋势，也就是车辆本身会往外侧（垫高一侧）甩，就像你家的洗衣机或者你那热爱蹦迪的男朋友/女朋友一样。甩完之后的结果是，车辆的中轴线和轨道的中心线不再在竖直面内平行，而是错开一定的距离，此时接触轨道的踏面也会向外移，那么<strong>实际接触到外侧轨道的踏面滚转半径就要比内侧大了。</strong>在严格的角速度相等的时候，两侧的线速度就会不相等，外侧比内侧大，也就不存在差速的问题了。多巧妙，是不是，这就是轨道交通的魅力。<br>本来想继续讲讲轨道和道岔的，内容都想好了，忽然有些感慨想说点别的，那这部分内容就留到下一篇吧。有人说能让一群男人为止奋斗的从来不是金钱而实梦想，我觉得同济轨交就是我的梦想。我在哈工大电气，也不错，但我能学到的终究还是电气的东西，即便是与轨道交通有关，也仅仅是“有关”罢了。要想真正走入这个行业，还是要跟着专业的人学专业的东西，坐专业的事情。中国铁路，无论是国铁还是地方铁路、城市轨道交通，其实一直在风口浪尖上。有人说中国的高铁技术都是国外引进的，中国技术不行，有人说中国修铁路太浪费钱。实际上真的是这样吗？我还没有走入这个行业里。我的前脚已经搭在门槛上了，等我进去看看便知分晓。但我想说，任何一种技术都是从无到有从零到一的，十几年前我们没有技术的时候引进了国外的技术，也是花了大价钱的，后来我们慢慢在发展，到今天我们有了自己标准的动车组，我们开始向国外出口中国生产的轨道交通车辆，作为一名向往轨道交通的人，我是很自豪的。我们的第一艘航母也是买的前苏联的，后面经过我们的研究还是造出了自己的航母。一样的，我们的C919是以A320为模板的，阿娇（ARJ21）也是从模仿开始一步一步提升的。中国的技术现在行不行，我们去看看中车的海外订单就知道了。那天我看了一个纪录片，超级工程第一季，其中一集讲到了北京地铁网络的建设，有一个片段让我热泪盈眶，我截了下来，放在这里。<br><img src="/old_images/2020/07/1405371260.gif" alt="TIM图片20200717000541.gif"><br><img src="/old_images/2020/07/3520035333.gif" alt="TIM图片20200717000707.gif"><br>写这篇文章的时候，脑海里多次会想起这个画面，每当我看到这个动图我都忍不住落泪。可能这就是热爱，可能这就是我热爱一项事业的方式。我希望自己能够进入到这个行业中去真正做一些事情。我们没有西门子那样将近两百年的发展历程，我们真的要做很多努力去超越和创新。对于轨道交通，我很自豪地讲我是有自己的想法的，也希望有朝一日我也能够再次热泪盈眶地说一句：<br>“为了搞我们国家自己的轨道交通事业，我们那代轨交人，可以说是付出了辛苦的，很自豪。”<br>谢谢。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家好，我是那个喜欢火车的Captain。&lt;br&gt;有人说，一个男人不成熟的标志是可以为了一项事业英勇地死去，而一个男人成熟的标志是可以为了一项事业卑贱地活着。我可能是成熟了。在上个周末，从7月10号到13号的四天时间里，我经历了两场专业课考试，一个夏令营，外加一篇恶心的硕士</summary>
      
    
    
    
    <category term="日常" scheme="http://starydy.xyz/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>新人报到！虚拟样机在机器人领域的应用（入门篇）</title>
    <link href="http://starydy.xyz/2020/07/13/%E6%96%B0%E4%BA%BA%E6%8A%A5%E5%88%B0%EF%BC%81%E8%99%9A%E6%8B%9F%E6%A0%B7%E6%9C%BA%E5%9C%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89/"/>
    <id>http://starydy.xyz/2020/07/13/%E6%96%B0%E4%BA%BA%E6%8A%A5%E5%88%B0%EF%BC%81%E8%99%9A%E6%8B%9F%E6%A0%B7%E6%9C%BA%E5%9C%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89/</id>
    <published>2020-07-13T05:33:00.000Z</published>
    <updated>2020-12-14T12:22:25.068Z</updated>
    
    <content type="html"><![CDATA[<p>Hello！大家好呀，我是你们的新朋友，也是宇哥的搭档。先自我介绍一下子哈，我的名字是冯宸，跟栋宇一样是哈工大竞技机器人队的现役队员，大家可以叫我Albert，主要是从事机械方向的工作，当然嵌入式和视觉方面也有（cai）所（de）涉（yi）猎（pi）。前几天偶然发现了栋宇的Blog，就想着抛砖引玉写一篇科普小文章，奈何才疏学浅再加上这几天事情比较多，就搁置了下来，不过今天刚好有时间，就尝试把自己之前弄的一些基础的小东西来支持一下我宇哥。好啦！废话不多说上才艺！</p><ol><li>虚拟样机技术简介<br>虚拟样机技术一般在大型复杂系统的产品设计中应用，虚拟样机技术 (Virtual Prototyping Technology)是指在产品开发设计过程中，将分散的零部件设计和分析技术融合在一起,在计算机上建造出整体模型,并针对该产品在投入使用后的各种工况进行仿真分析，预测产品的整体性能，通过仿真结果指导改进设计、提高产品性能。<br>一般流程是在仿真软件中搭建一个动力学模型来模拟系统工作时的工作状态,通过数据输出(位移、速度、加速度)或者仿真动画输出来观察和分析系统的可靠性，分析结果用来指导物理样机 的版本迭代。<br>在RoboMaster 比赛中,如果能搭建正确的战车一些核心模块的虚拟样机,在方案试验阶段能节省很大一部分的人力成本资金成本和时间成本.并且能在分析问题时有一定说服力的依据而不是只停留在经验层面上,解决问题一针见血。</li><li>常用虚拟样机软件<br>自然界广泛存在四种物理场：温度场、电磁场、结构(位移、应力、应变)场、流场 。<br>不同的工程所分析的物理场不一样,不同的物理场所应用的公式理论和仿真软件也不一样.本文主要针对robomaster 比赛中机械仿真案例进行阐述.目前来看主要是运用结构场和流场 进行建模分析.其中涉及到多体动力学分析和静力学分析以及流体力学分析。一般涉及到软件Solidworks、Adams、Ansys workbench、Fluent… 等。<br>Solidworks 主要进行三维建模设计也可进行关键零件的静力学分析(Simulition静力学模块)和动力学模型搭建(motion模块)。<br>Adams 是多体动力学仿真计算中最常用的软件,也是本文的中点阐述对象.可以进行动力学模型搭建(View模块)仿真求解(Solver模块)以及数据处理模块(Postprocessor模块)<br>Ansys 是有限元仿真中常用软件，可以进行静力学分析(Static Structural模块)也可以进行碰撞分析(LS-dyna模块)还有流场分析(Fluid Flow模块)，Workbench集成了很多有限元模块，可以共享各自的结果数据使Ansys的功能异常强大。<br>结构场是最主要的分析场.本文是在结构场中以步兵拨弹模块 为例进行展开系统的虚拟样机搭建过程.研究Adams虚拟样机中17mm子弹在弹仓中的运动状态和拨轮受力情况，指导拨弹模块的改进，进而提高射频满足比赛要求。</li><li>搭建虚拟样机的动力学模型<br>简单的机械系统可以搭建数学模型进行动力学分析,但是像拨弹这中多自由度的复杂系统很难或者无法直接搭建整个拨弹过程的数学模型,只能通过多体动力学软件搭间接搭建数学模型进行迭代计算和过程动画模拟来分析问题。<br>虚拟样机其实包括建模、仿真、后处理.建模即创建样机添加工况,仿真即是求解方程,由计算机幕后完成,后处理主要是查看动画以及输出一些感兴趣的物理量,复杂的由专业后处理模块Adams/PostProcessor进行。<br>在Solidworks中的motion模块和Adams View中均可搭建动力学模型。Solidworks中操作比较简单，对于大多数同学来讲上手比较快。可以把模型在SW中搭建好之后导入到Adams进行求解计算，这样可以在短时间内完成一个简单系统的仿真工作，不过如果需要更精确的求解计算建议还是使用Adams搭建模型比较好，求解更精确。</li></ol><p>4.在Solidworks中简化模型导入Adams计算和后处理<br>（1）在solidworks中简化拨弹模块，压缩不影响本次研究问题的无关零件(发射模块、弹舱盖、其他保护壳等)。并添加上子弹,子弹是阵列生成,需要右键解散阵列 .所有零件应赋材料(子弹材料TPE,用PA代替)如图4-1到图4-2的简化。<br><img src="/old_images/2020/07/1225674126.png" alt="1.PNG"></p><p>图4-1简化前    图4-2简化后<br>（2）打开【motion】插件,进入motion模块(如没有在→插件中勾选motion),在左下角将页面切换至【运动算例1】 ,将下拉菜单【动画】切换到【motion分析】 ,依次添加各个实体间的接触力contact(球与球之间、球与拨轮之间、球与弹舱之间),检查弹舱为固定状态,最后设置重力 .到此为止,模型搭建完毕,驱动马达可以不添加,放在Adams 中操作.图4-3是各按钮位置。<br><img src="/old_images/2020/07/51341367.png" alt="2.PNG"></p><p>图4-3 motion模块的操作界面<br>在动力学模型中每个实体之间的接触是靠添加两个物体间的接触力实现的,在Adams和Solidworks中每个接触均有8个参数(图4-7中标出),四个碰撞参数:Stiffness(刚度系数)、Force Exponent(刚度指数)、Damping(阻尼系数)、Penetration Depth(最大穿透值),四个库仑摩擦参数:Static Coefficient(静摩擦系数)、Dynamic Coefficient(动摩擦系数)、Stiction Transition Vel(静摩擦过渡速度)、Friction Transition Vel(动摩擦过渡速度), 表3-1给出大致参数确定方法，也可参考附件data文件夹下《ADAMS中接触的定义及参数设置》.图4-4和图4-5方便理解各个参数的意义。<br><img src="/old_images/2020/07/1260733011.png" alt="3.PNG"></p><p>表3-1 Impact接触参数与Coulomb摩擦参数</p><p><img src="/old_images/2020/07/4243678235.png" alt="4.PNG"></p><p>图4-4 Impact接触参数参考图    图4-5 Coulomb摩擦参数参考图</p><p><img src="/old_images/2020/07/3134056928.png" alt="5.PNG">    </p><p>图4-6 各球之间接触    图4-7各球之间的接触参数设置<br>图4-6为添加球和球接触中实体选择操作,可以看出不勾选接触组时,添加的是所选择各实体间的接触,17颗球之间一共有136个接触.图4-7为球和球之间的接触参数设置(推荐)。</p><p><img src="/old_images/2020/07/3001651570.png" alt="6.PNG"></p><p>图4-8球和各个弹舱零件的接触    图4-9 球与弹舱之间的接触参数设置<br>图4-8使用【接触组】添加接触,球和拨轮以及球和弹舱的接触需要使用接触组,即球为一组与另外三个零件分别添加接触,各球之间接触不会被重复添加,在图中看出17个子弹与四个零件间分别添加接触,共68个接触. 图4-9为球和弹舱之间的接触参数设置(推荐)。<br>另外拨轮和球之间的接触同样使用接触组,系数设置中将图4-9中【Stiffness】(刚度)系数改为400即可。<br>使用Solidworks 方便交互式批量添加各实体间的接触力,Adams 中接触力的添加比较难操作.多个实体之间只有用脚本命令进行添加比较方便。<br>最后添加上重力。<br>（3）导入到Adams中,检查模型,稍作修改,一些复杂的约束用简单约束来替换,在Solidworks 中的互相固连的零件可以进行两种操作①两个零件用Fixed约束锁死②使用Boolean运算进行零件合并,给拨轮添加Revolute铰接约束,在铰接约束上添加motion驱动.打开求解器进行运算即可。</p><p><img src="/old_images/2020/07/2541934723.png" alt="7.PNG"></p><p>图4-10计算按钮    图4-11 Solidworks与Adams的接口<br>把模型按照第一第二步搭建完之后,点击【计算】按钮(图4-10),计算结果一般都会报错可以忽略,Solidworks中的求解器计算很容易失败,所以只用motion做模型搭建这种前处理工作.右键模型名称输出Adams(图4-11),输出英文命名的.adm文件和一些.xmt_bin以及.res文件均保存在英文路径下.附件中例程保存在 adams_file\project\model\adams_1中。</p><p><img src="/old_images/2020/07/723480778.png" alt="8.PNG"></p><p>图4-12导入.adm文件    图4-13 MKS单位制设置<br>打开Adams导入.adm文件,新建模型“loader_1”,设置单位制。</p><p><img src="/old_images/2020/07/962343059.png" alt="9.PNG"></p><p>图4-14 Connectors约束    图4-15 添加Fixed约束</p><p><img src="/old_images/2020/07/2140554824.png" alt="10.PNG"></p><p>图4-15 Fixed(固定)和Revolute(旋转)约束<br>在Adams中删除【Connectors】中所有约束,将几个固定零件间添加Fixed约束(固定锁死)。</p><p><img src="/old_images/2020/07/4097717059.png" alt="11.PNG"></p><p>图4-16 右键→Appearance    图4-17 Appearance→Color<br>更改拨轮颜色为Red,方便观察和操作,如图4-16和图4-17.也可以根据需要更改其他零件颜色.图4-17中【Visibility】点选off即可隐藏该零件,该操作同样适用于其他类型信息,如Connectors、Motion、Force等。</p><p><img src="/old_images/2020/07/551017501.png" alt="12.PNG"></p><p>图4-18添加Revolute(旋转)约束    图4-19 Revolute(旋转)约束结果<br>在拨轮和弹舱中间添加旋转副,操作如图4-18结果如图4-19。</p><p><img src="/old_images/2020/07/3819593002.png" alt="13.PNG"></p><p>图4-20 Rotational Joint motion(旋转驱动)</p><p><img src="/old_images/2020/07/3351283967.png" alt="14.PNG">    </p><p>图4-20 motion结果    图4-21 motion参数<br>    将旋转驱动添加到拨轮的旋转副上。<br>在joint_4上添加motion_1,参数设置如图4-21。<br>17mm子弹材料为TPE,密度970 kg/m³弹性模量3.4GPa,泊松比0.32(近似)。</p><p><img src="/old_images/2020/07/1559317015.png" alt="15.PNG"></p><p>图4-22 新建材料    图4-23 TPE材料参数<br>【body】树下右键其中一个球单击【Modify】, 出现对话框如图4-22在【Define Mass By】下拉菜单选择【Geometry and Material Type】,在【Material Type】中右键出现图中对话框,依次选取【Material】→【Create】会跳出对话框如图4-23，按照TPE参数设置单击【Apply】→【ok】,然后单击图4-22中【Apply】即发现图中材料参数刷新至新建TPE材料.依次添加剩余球的材料和弹仓材料(【Material】→【Guesses】→【aluminum】)。模型搭建完毕,进入simulation进行求解计算。</p><p><img src="/old_images/2020/07/3888322204.png" alt="16.PNG"></p><p>图4-24仿真参数设置<br>如图4-24仿真正在进行中,左上角为仿真计算过的模型时间,右下角为仿真进程百分比,在Simulation Control对话框中【End Time】为仿真总时长,【Step Size】为仿真步长根据模型复杂程度给定,合理的步长节省仿真时间、提高仿真精度.如果计算报错则检查模型有无物理干涉和严重死点,调整仿真时间继续进行仿真计算,多次仿真计算应勾选【Reset before running】保证每次仿真计算前参数重置.仿真时间由模型复杂度和电脑CPU以及内存而定,如果模型复杂则仿真时间会十几个小时甚至几天，电脑配置稍好些会加快运算效率.另外合理的模型化简和模型搭建也能影响仿真时间。<br>关于充分利用电脑性能加快仿真速度,可以开从多线程运算和增大可调用内存两个方面入手。<br>多线程运算途径&gt;在Adams/View界面下通过“settings&gt;solver&gt;Executable”菜单打开设置窗口，并勾选More选项，在Thread Count位置输入参与计算的线程数(128).如图4-25。</p><p><img src="/old_images/2020/07/2310258600.png" alt="17.PNG"></p><p>图4-25<br>增大调用内存途径&gt;开始–程序–MSC.software–MSC.ADAMS–ADAMS settings分别打开Aview和Asolver中的Preference，在右侧memsize一栏中选择huge点击ok保存。重新运行ADAMS即可.如图4-26。</p><p><img src="/old_images/2020/07/291067937.png" alt="18.PNG"></p><p>图4-26<br>（4）进入后处理模块Postprocessor,观察动画可以看到子弹在拨轮中的运状态,进行子弹轨迹追踪和一些感兴趣物理量的测量.比如输出电机的驱动扭矩值,进行电机选型.通过仿真动画和数据指导版本迭代改进。<br>5.Solidworks提供三维模型,Adams中进行模型搭建和计算及后处理<br>（1）Solidworks简化模型,操作过程和流程和4.1中相同,最后将装配体另存成Parasolid(*.x_t)格式如图5-1,导入Adams做前处理.注意:Adams不支中文路径和中文文件名。</p><p><img src="/old_images/2020/07/755844939.png" alt="19.PNG"></p><p>图5-1导出x_t<br>打开Adams View,新建模型导入.x_t文件.单击【New Model】输入自定义模型名称(英文),单击【ok】会新建一个空白模型,【主菜单】&gt;【File】&gt;【import】下拉菜单第一个【File Type】中选择Parasolid,在【File To Read】中右键&gt;【Browse】浏览到目标.x_t文件,在【Model Name】右键选择新建的模型名称.单击【Ok】.模型导入完成.如图5-2。</p><p><img src="/old_images/2020/07/270229372.png" alt="20.PNG"></p><p>图5-2 .x_t导入Adams<br>（2）在Adams里面搭建动力学模型.在此之前应掌握Adams图形界面基本操作和工具栏的分布.模型需要用cmd脚本搭建,准确高效,所以要求能读懂简单的编程语言.本章节均用一些简单的命令语言来实现建模操作.这里的脚本编辑器使用的是VScode,桌面新建.txt英文命名后缀改为.cmd,用VScode打开编辑后保存即可。<br>【主菜单】&gt;【View】&gt;【Command Window】打开命令窗口,每一步界面操作的命令都会在命令窗口中滚动.可以复制出来修改后使用。<br>Cmd脚本对拨弹部分建模流程如下①修改Bodies Name②布尔运算操作③定义材料④添加约束⑤添加驱动⑥定义接触力(部分步骤的先后顺序可调)。<br>①基本设置<br>设置单位制(MKS)和重力方向(-Z)。<br>!————-setting———————-!<br>default units length=mm mass=kg force=newton &amp;<br> time=Second angle=degrees frequency=hz!units_MKS!</p><p>int dia disp dia=gravity_panel!打开对话框重力设置对话框!<br>force modify body gravitational gravity = ACCGRAV_1 &amp;<br>      x_comp = 0 &amp;<br>      y_comp = 0 &amp;<br>      z_comp = -9806.65!-Z轴gravity!<br>!—————–end————————!<br>②修改Bodies Name<br>在模型树中【Bodies】下可以查看各个实体.如果在Solidworks中是中文命名,导入后会重新命名,但是命名均有规律.现需要修改实体名字,方便查看和操作。<br>图形界面操作按钮如图5-3,【模型树】&gt;【Bodies】&gt;【任意一组件右键】。</p><p><img src="/old_images/2020/07/3548240241.png" alt="21.PNG"></p><p>图5-3 Rename按钮</p><pre><code>图形界面操作按钮如图5-3,【模型树】&gt;【Bodies】&gt;【任意一组件右键】，根据模型树中的信息,编写modify_name命令如下,</code></pre><p>!————-modify_part_name—————!<br>entity modify entity =____002    new = wheel_loader<br>entity modify entity =<strong>__       new = magazin_1<br>entity modify entity =_______2   new = sheet<br>entity modify entity =____</strong>     new = magazin_2</p><p>entity modify entity =<em>17mm____  new = <em>17mm_____1<br>for variable_name=ip  start_value=1  end_value=17 !for循环批量修改球的name,ip为变量名!<br>entity modify entity =(eval(“<em>17mm__</em></em></em>“//rtoi(ip))) new =(eval(“ball_”//rtoi(ip)))<br>end</p><p>entity modify entity =<strong>____</strong>   new = _________1<br>for variable_name=ip  start_value=1  end_value=2<br>entity modify entity =(eval(“_________”//rtoi(ip))) new = (eval(“pipe_”//rtoi(ip)))<br>end<br>!——————-end———————-!<br>根据模型树中的信息,编写modify_name命令如下,通过【主菜单】&gt;【File】&gt;【import】导入.cmd实现对模型的操作如图5-4，</p><p><img src="/old_images/2020/07/2308466294.png" alt="22.PNG"></p><p>图5-4 .cmd导入Adams<br>操作前后的对比如图5-5和图5-6</p><p><img src="/old_images/2020/07/3991564688.png" alt="23.PNG"></p><p>图5-5 Bodies Name修改前    图5-6 Bodies Name修改后<br>③布尔运算操作<br>在三维模型为DFM(面向制造的设计),不影响功能情况下,使用布尔运算将多个零件合成一个。<br>图形界面操作按钮如图5-7,【功能区】&gt;【Bodies】&gt;【Booleans】。</p><p><img src="/old_images/2020/07/162826487.png" alt="24.PNG"></p><p>图5-7 Booleans操作按钮<br>根据模型,编写Booleans命令操作如下,<br>!————-Booleans_parts—————–!<br>part merge rigid_body part_name=pipe_2 into_part=pipe_1!将pipe_2合并到pipe_1!<br>!——————-end———————-!<br>操作前和操作后的区别如图5-8和图5-9</p><p><img src="/old_images/2020/07/995794732.png" alt="25.PNG"></p><p>图5-8 布尔合并前</p><p><img src="/old_images/2020/07/1501298663.png" alt="26.PNG"></p><p>图5-9 布尔合并后<br>④定义材料<br>图形界面操作按钮,【模型树】&gt;【Bodies】&gt;【任意一个构件右键】&gt;【Modify】接下来的操作设置如图5-10和图5-11</p><p><img src="/old_images/2020/07/3087868713.png" alt="27.PNG"></p><p>图5-10 新建材料    图5-11TPE材料参数<br>材料参数:①密度(Density)②弹性模量(Youngs Modulus)③泊松比(Poissons Ratio)<br>根据模型,编写Material命令操作如下,<br>!————-modify_material—————–!<br>material create  &amp;                !新建材料TPE!<br>      material_name = .materials.TPE  &amp;<br>      density = 0.97e-6 &amp;<br>      youngs_modulus = 3400  &amp;<br>      poissons_ratio = 0.32<br>for variable_name=ip start_value=1 end_value=17!for循环批量修改!<br> part modify rigid mass_properties  &amp;<br>      part_name = (eval(“ball_”//rtoi(ip)))  &amp;<br>      material_type = .materials.TPE<br>end</p><p>part modify rigid mass_properties  &amp;<br>      part_name = pipe_1  &amp;<br>      material_type = .materials.aluminum<br>part modify rigid mass_properties  &amp;<br>      part_name = magazin_1  &amp;<br>      material_type = .materials.aluminum<br>part modify rigid mass_properties  &amp;<br>      part_name = sheet  &amp;<br>      material_type = .materials.aluminum<br>part modify rigid mass_properties  &amp;<br>      part_name = wheel_loader  &amp;<br>      material_type = .materials.aluminum<br>!——————-end———————-!<br>修改前后对比如图5-12和图5-13</p><p><img src="/old_images/2020/07/2048957230.png" alt="28.PNG"></p><p>图5-12 新建材料    图5-13 TPE材料参数<br>⑤添加约束<br>在此模型中每个子弹都有6个自由度,不存在约束,剩余零部件都有自己的固定方式.如图5-14中,wheel_loader和ground有个旋转约束,其余零件和ground都是固定约束。</p><p><img src="/old_images/2020/07/1700994165.png" alt="29.PNG"></p><p>图5-14 模型树中需要约束的零部件<br>图形界面操作按钮如图5-15</p><p><img src="/old_images/2020/07/2612196784.png" alt="30.PNG"></p><p>图5-15 Fixed(固定)和Revolute(旋转)约束<br>·固定约束(Fixed Joint)<br>根据模型,编写Fixed_joint命令操作如下,<br>!—————Fixed_Joint——————!<br>marker create marker=.ground.MAR_fixed_1 &amp; !在ground上创建marker点命MAR_fixed_1!<br>location=(LOC_RELATIVE_TO({0,0,0},ground.cm)) &amp;!MAR_fixed_1和ground.cm位置重合!<br>orientation=0.0,0.0,0.0                          !MAR_fixed_1和ground.cm坐标重合!<br>marker create marker=.sheet.MAR_fixed_1 &amp;!在ground上创建marker点命名MAR_fixed_1!<br>  location=(LOC_RELATIVE_TO({0,0, 0},ground.cm)) &amp;!MAR_fixed_1和ground.cm位置合!<br>  orientation=0.0, 0.0, 0.0                       !MAR_fixed_1和点ground.cm坐标重合!<br>constraint create joint Fixed &amp;           !在上述创建的两个marker间创建一个固定约束!<br>    joint_name=fixed_1 &amp;                   !Fixed约束的名称!<br>    i_marker_name=.sheet.MAR_fixed_1 &amp;<br>    j_marker_name=.ground.MAR_fixed_1</p><p>marker create marker=.ground.MAR_fixed_1 &amp;<br>    location=(LOC_RELATIVE_TO({0,0, 0},ground.cm)) &amp;<br>    orientation=0.0, 0.0, 0.0<br>marker create marker=.magazin_1.MAR_fixed_1 &amp;<br>    location=(LOC_RELATIVE_TO({0,0, 0},ground.cm)) &amp;<br>    orientation=0.0, 0.0, 0.0<br>constraint create joint Fixed &amp;                     !创建固定约束!<br>    joint_name=fixed_2 &amp;<br>    i_marker_name=.magazin_1.MAR_fixed_1 &amp;<br>    j_marker_name=.ground.MAR_fixed_1</p><p>marker create marker=.ground.MAR_fixed_1 &amp;<br>    location=(LOC_RELATIVE_TO({0,0,0},ground.cm)) &amp;<br>    orientation=0.0, 0.0, 0.0<br>marker create marker=.pipe_1.MAR_fixed_1 &amp;<br>    location=(LOC_RELATIVE_TO({0,0,0},ground.cm)) &amp;<br>    orientation=0.0, 0.0, 0.0<br>constraint create joint Fixed &amp;                     !创建固定约束!<br>    joint_name=fixed_3 &amp;<br>    i_marker_name=.pipe_1.MAR_fixed_1 &amp;<br>    j_marker_name=.ground.MAR_fixed_1<br>!——————-end———————-!<br>创建Fixed后如图5-16</p><p><img src="/old_images/2020/07/2817136246.png" alt="31.PNG"></p><p>图5-16 固定约束的结果图<br>·旋转约束(Revolute Joint)<br>需要在拨盘(wheel_loader)和ground之间添加旋转约束，根据模型,编写Revolute_joint命令操作如下,<br>variable create variable_name=wheel_name string_value=”wheel_loader” !定义变量”wheel_name”,string_value代表字符串类型!<br>marker create marker=.ground.run_MAR_1 &amp;<br>    location=(LOC_RELATIVE_TO({0,0,0},(eval(wheel_name//“.cm”)))) &amp;!<br>    orientation=(ORI_RELATIVE_TO({90,90,0},(eval(wheel_name//“.cm”))))<br>marker create marker=.wheel_loader.run_MAR_2 &amp;<br>    location=(LOC_RELATIVE_TO({0,0,0},(eval(wheel_name//“.cm”)))) &amp;<br>    orientation=(ORI_RELATIVE_TO({90,90,0},(eval(wheel_name//“.cm”))))<br>constraint create joint Revolute &amp;              !创建Joint_Revolute!<br>    joint_name=run_1 &amp;            !约束名称!<br>    i_marker_name=.ground.run_MAR_1 &amp;<br>    j_marker_name=.wheel_loader.run_MAR_2<br>variable delete variable_name=wheel_name                    !删除变量!<br>Adams中建模命令均是对是通过对Marker点的操作来完成的,拿创建旋转副举例(固定约束同理),分为三步：<br>i.创建一个坐标点run_MAR_1,该点在ground上,与wheel_loader.cm重合。<br>ii.创建另外一个坐标点run_MAR_2,该点在wheel_loader上,依旧与wheel_loader.cm重合。<br>iii.创建一个转动副,转动副名字为.loader_2.run_1,他是由于两个坐标点发生相对转动构成的,这两个坐标点分是上述两步创建的坐标。<br>此外上述脚本开头定义了一个字符串变量wheel_name,在创建Joint中使用,结尾删除.使用变量可以方便代码移植。<br>⑥添加驱动<br>Adams中驱动一般添加在旋转副或者移动副上,拨弹模块只需添加拨盘旋转，图形界面操作按钮如图5-17</p><p><img src="/old_images/2020/07/3860621436.png" alt="32.PNG"></p><p>图5-17 Rotational Joint motion(旋转驱动)<br>根据模型,编写Joint Motion命令操作如下，<br>!————-Revolute_Joint—————-!<br>variable creat variable_name=MC_run_1 string_value=”step(time,0.1,0,0.3,-360d)”!电机转速!<br>constraint create motion motion_name=.loader_2.motion_1 &amp;<br>           joint=.loader_2.run_1 &amp;                 !motion添加在run_1上!<br>           type=rotational &amp;                       !类型是转动!<br>           time_derivative=velocity &amp;              !驱动类型为velocity(速度)!<br>           function=(eval(MC_run_1))               !调用定义的变量MC_run_1!<br>!——————-end———————-!<br>使用step函数定义驱动,step函数：<br>STEP（time，1，0d，2，20d）+STEP（time，6，0d，12，-40）<br>意义：1秒到2秒：从0递增至20d；<br>2秒到6秒：保持电机输出数值为20d不变；<br>6秒到12秒：由20d递减40d，结果为-20d<br>旋转约束和驱动添加之后的结果如图5-18</p><p><img src="/old_images/2020/07/3240034142.png" alt="33.PNG"></p><p>图5-18添加旋转约束和驱动<br>⑦定义接触力<br>在Adams中所有的碰撞接触的均应添加接触力。<br>该模型中接触力的添加操作要稍微复杂,每个球都有6个自由度,所以每两个球之间都要有添加接触力,第四节中已经说明球之间需要添加136个接触力,需要使用命令批量添加，准确高效。<br>图形界面操作按钮如图5-19【功能区】&gt;【Forces】&gt;【Special Forces】&gt;【Create a contact】。</p><p><img src="/old_images/2020/07/2422714402.png" alt="34.PNG"></p><p>图5-19 添加实体间接触力按钮<br>根据模型,编写Create contact命令操作如下<br>!————create_contact_between_solids————–!<br>variable create variable_name=MODEL_name string_value=”loader_2”!模型名称!<br>variable create variable_name=part_box string_value=”CSG_4”!被接触对象!</p><p>variable create variable_name=add_1 integer_value=6!子弹Body名称和SOLID名称的序号差!</p><p>variable create variable_name=MC_stiffness  real_value=164 !刚度系数,计算公式参考stiffness.m!<br>variable create variable_name=MC_damping    real_value=0.5 !阻尼系数!<br>variable create variable_name=MC_exponent   real_value=2 !指数!<br>variable create variable_name=MC_dmax       real_value=0.00005!最大实体入侵!</p><p>variable create variable_name=MC_mu_static  real_value=0.7 !静摩擦系数!<br>variable create variable_name=MC_mu_dynamic real_value=0.65!动摩擦系数!<br>variable create variable_name=MC_sti_tra_vel real_value=0.1!静摩擦过渡速度!<br>variable create variable_name=MC_fri_tra_vel real_value=10 !动摩擦过渡速度!</p><p>!—————sheet————-!<br> variable modify variable_name=part_box &amp;<br>      string=SOLID2                           !修改part_box为sheet的Solid!<br>variable modify variable_name=MC_stiffness  real_value=4.4e8<br>variable modify variable_name=MC_damping    real_value=5e4<br>variable modify variable_name=MC_exponent   real_value=1.5<br>variable modify variable_name=MC_dmax       real_value=0.01<br>for variable_name=ipp  start_value=1  end_value=17<br>contact create &amp;<br>  contact_name = .(eval(MODEL_name)).(eval(“con_”//rtoi(ipp+add_1)//“<em>“//(eval(part_box)))) &amp;<br>      i_geometry_name = (eval(“SOLID”//rtoi(ipp+add_1))) &amp;<br>      j_geometry_name = (eval(part_box))  &amp;<br>      stiffness = (eval(MC_stiffness))    &amp;<br>      damping =(eval(MC_damping))         &amp;<br>      exponent =(eval(MC_exponent))       &amp;<br>      dmax =(eval(MC_dmax))               &amp;<br>      coulomb_friction = on               &amp;<br>      mu_static =(eval(MC_mu_static))          &amp;<br>      mu_dynamic =(eval(MC_mu_dynamic))         &amp;<br>      stiction_transition_velocity =(MC_sti_tra_vel) &amp;<br>      friction_transition_velocity =(MC_fri_tra_vel)<br>end<br>!—————magazin_1————-!<br> variable modify variable_name=part_box &amp;<br>      string=SOLID1<br>variable modify variable_name=MC_stiffness  real_value=4.4e8<br>variable modify variable_name=MC_damping    real_value=5e4<br>variable modify variable_name=MC_exponent   real_value=1.3<br>variable modify variable_name=MC_dmax       real_value=0.01<br>for variable_name=ipp  start_value=1  end_value=17<br>contact create &amp;<br>  contact_name = .(eval(MODEL_name)).(eval(“con</em>“//rtoi(ipp+add_1)//“<em>“//(eval(part_box)))) &amp;<br>      i_geometry_name = (eval(“SOLID”//rtoi(ipp+add_1))) &amp;<br>      j_geometry_name = (eval(part_box))  &amp;<br>      stiffness = (eval(MC_stiffness))    &amp;<br>      damping =(eval(MC_damping))         &amp;<br>      exponent =(eval(MC_exponent))       &amp;<br>      dmax =(eval(MC_dmax))               &amp;<br>      coulomb_friction = on               &amp;<br>      mu_static =(eval(MC_mu_static))          &amp;<br>      mu_dynamic =(eval(MC_mu_dynamic))         &amp;<br>      stiction_transition_velocity =(MC_sti_tra_vel) &amp;<br>      friction_transition_velocity =(MC_fri_tra_vel)<br>end<br>variable modify variable_name=part_box &amp;<br>      string=SOLID3<br>for variable_name=ipp  start_value=1  end_value=17<br>contact create &amp;<br>  contact_name = .(eval(MODEL_name)).(eval(“con_”//rtoi(ipp+add_1)//“_”//(eval(part_box)))) &amp;<br>      i_geometry_name = (eval(“SOLID”//rtoi(ipp+add_1))) &amp;<br>      j_geometry_name = (eval(part_box))  &amp;<br>      stiffness = (eval(MC_stiffness)) &amp;<br>      damping =(eval(MC_damping)) &amp;<br>      exponent =(eval(MC_exponent))&amp;<br>      dmax =(eval(MC_dmax))  &amp;<br>      coulomb_friction = on  &amp;<br>      mu_static =(eval(MC_mu_static)) &amp;<br>      mu_dynamic =(eval(MC_mu_dynamic)) &amp;<br>      stiction_transition_velocity =(MC_sti_tra_vel) &amp;<br>      friction_transition_velocity =(MC_fri_tra_vel)<br>end<br>!—————pipe_1————-!<br> variable modify variable_name=part_box &amp;<br>      string=SOLID4<br>variable modify variable_name=MC_stiffness  real_value=4.4e8<br>variable modify variable_name=MC_damping    real_value=5e4<br>variable modify variable_name=MC_exponent   real_value=1.5<br>variable modify variable_name=MC_dmax       real_value=0.01<br>for variable_name=ipp  start_value=1  end_value=17<br>contact create &amp;<br>  contact_name = .(eval(MODEL_name)).(eval(“con</em>“//rtoi(ipp+add_1)//“<em>“//(eval(part_box)))) &amp;<br>      i_geometry_name = (eval(“SOLID”//rtoi(ipp+add_1))) &amp;<br>      j_geometry_name = (eval(part_box))  &amp;<br>      stiffness = (eval(MC_stiffness))    &amp;<br>      damping =(eval(MC_damping))         &amp;<br>      exponent =(eval(MC_exponent))       &amp;<br>      dmax =(eval(MC_dmax))               &amp;<br>      coulomb_friction = on               &amp;<br>      mu_static =(eval(MC_mu_static))          &amp;<br>      mu_dynamic =(eval(MC_mu_dynamic))         &amp;<br>      stiction_transition_velocity =(MC_sti_tra_vel) &amp;<br>      friction_transition_velocity =(MC_fri_tra_vel)<br>end<br>variable modify variable_name=part_box &amp;<br>      string=SOLID5<br>for variable_name=ipp  start_value=1  end_value=17<br>contact create &amp;<br>  contact_name = .(eval(MODEL_name)).(eval(“con_”//rtoi(ipp+add_1)//“_”//(eval(part_box)))) &amp;<br>      i_geometry_name = (eval(“SOLID”//rtoi(ipp+add_1))) &amp;<br>      j_geometry_name = (eval(part_box))  &amp;<br>      stiffness = (eval(MC_stiffness)) &amp;<br>      damping =(eval(MC_damping)) &amp;<br>      exponent =(eval(MC_exponent))&amp;<br>      dmax =(eval(MC_dmax))  &amp;<br>      coulomb_friction = on  &amp;<br>      mu_static =(eval(MC_mu_static)) &amp;<br>      mu_dynamic =(eval(MC_mu_dynamic)) &amp;<br>      stiction_transition_velocity =(MC_sti_tra_vel) &amp;<br>      friction_transition_velocity =(MC_fri_tra_vel)<br>end<br>!—————wheel_loader————-!<br> variable modify variable_name=part_box &amp;<br>      string=SOLID6<br>variable modify variable_name=MC_stiffness  real_value=4.4e8<br>variable modify variable_name=MC_damping    real_value=5e4<br>variable modify variable_name=MC_exponent   real_value=1.5<br>variable modify variable_name=MC_dmax       real_value=0.01<br>for variable_name=ipp  start_value=1  end_value=17<br>contact create &amp;<br>  contact_name = .(eval(MODEL_name)).(eval(“con</em>“//rtoi(ipp+add_1)//“_”//(eval(part_box)))) &amp;<br>      i_geometry_name = (eval(“SOLID”//rtoi(ipp+add_1))) &amp;<br>      j_geometry_name = (eval(part_box))  &amp;<br>      stiffness = (eval(MC_stiffness))    &amp;<br>      damping =(eval(MC_damping))         &amp;<br>      exponent =(eval(MC_exponent))       &amp;<br>      dmax =(eval(MC_dmax))               &amp;<br>      coulomb_friction = on               &amp;<br>      mu_static =(eval(MC_mu_static))          &amp;<br>      mu_dynamic =(eval(MC_mu_dynamic))         &amp;<br>      stiction_transition_velocity =(MC_sti_tra_vel) &amp;<br>      friction_transition_velocity =(MC_fri_tra_vel)<br>end<br>!—————contact_between_balls——————-!<br>variable modify variable_name=MC_stiffness  real_value=1.64e8<br>variable modify variable_name=MC_damping    real_value=2e4<br>variable modify variable_name=MC_exponent   real_value=2<br>variable modify variable_name=MC_dmax       real_value=0.1<br>variable modify variable_name=MC_mu_static  real_value=0.35 !静摩擦系数!<br>variable modify variable_name=MC_mu_dynamic real_value=0.3!动摩擦系数!<br>!—————————————!<br>variable create variable_name=ipp   integer_value=1<br>variable create variable_name=a      integer_value=1!第一颗子弹的序号!<br>variable create variable_name=b      integer_value=17!最后一颗子弹的序号!<br>variable create variable_name=add_2  integer_value=1</p><p>for variable_name=num_1 start_value=(eval(a)) end_value=(eval(b-1))!两个for循环,依次添加子弹之间的各约束!</p><p>for variable_name=num_2 start_value=(eval(a))  end_value=(eval(b-ipp))<br>contact create &amp;<br>  contact_name =.(eval(MODEL_name)).(eval(“con_”//rtoi(num_1)//“_”//rtoi(num_1+add_2))) &amp;<br>      i_geometry_name = (eval(“SOLID”//rtoi(num_1+add_1))) &amp;<br>      j_geometry_name = (eval(“SOLID”//rtoi(num_1+add_1+add_2)))  &amp;<br>      stiffness = (eval(MC_stiffness)) &amp;<br>      damping =(eval(MC_damping)) &amp;<br>      exponent =(eval(MC_exponent))&amp;<br>      dmax =(eval(MC_dmax))  &amp;<br>      coulomb_friction = on  &amp;<br>      mu_static =(eval(MC_mu_static)) &amp;<br>      mu_dynamic =(eval(MC_mu_dynamic)) &amp;<br>      stiction_transition_velocity =(MC_sti_tra_vel) &amp;<br>      friction_transition_velocity =(MC_fri_tra_vel)<br>variable modify variable_name=add_2  integer_value=(eval(add_2+1))<br>end<br>variable modify variable_name=ipp integer_value=(eval(ipp+1))<br>variable modify variable_name=add_2 integer_value=1<br>end</p><p>variable delete variable_name=ipp<br>variable delete variable_name=a<br>variable delete variable_name=b</p><p>variable delete variable_name=MODEL_name<br>variable delete variable_name=part_box</p><p>variable delete variable_name=add_1<br>variable delete variable_name=add_2<br>!———————–end——————————!</p><p>到此为止动力学模型已经搭建完毕,其中一些参数设置一般指接触力参数和仿真步长参数,尤其使接触力参数中的刚度系数和阻尼系数需要查询资料来确定,作者在这一块也没有太明确的方法,文献中显示stiffness标准值是在1.0<em>e+7~1.0</em>e+9(N/m)之间，阻尼系数一般取stiffness的0.01%。<br>材料参数如表5-1</p><p><img src="/old_images/2020/07/81368647.png" alt="35.PNG"></p><p>表5-1</p><p>⑧设置仿真时长和步长开始仿真<br>本模型中有17个子弹,200个接触,如果40个子弹,各部分接触达到1000个.仿真时长取决于具体物理场景，仿真步长取决于模型复杂度，步长越小，计算结果越容易收敛，模型越精确，步长过大结果发散后就会报错。但是步长过小计算就变慢，合适的步长有利于模型仿真计算。<br>本案例中步长给0.0005~0.001比较合适，时长给2s既可以说明问题如图。</p><p><img src="/old_images/2020/07/249903794.png" alt="36.PNG"></p><p>图5-21仿真细节参数<br>⑨查看仿真结果输出物理量曲线或者动画,细化模型参数,模型正确即可指导方案迭代。<br>⑩一般的搭建过程如图,徐要验证和迭代框图5-21。</p><p><img src="/old_images/2020/07/489071846.png" alt="37.PNG"></p><pre><code>虚拟样机的需要按照上述的流程循环迭代,不能凭空搭建样机,要有实验数据做基础,有样机迭代使虚拟样机模型越来越精确,模型越精确越有利于实际工程的分析。当一个模型搭建正确之后,类似的机构搭建周期将会缩短。</code></pre><p>⑪查看仿真结果输出物理量曲线或者动画,细化模型参数,模型正确即可指导方案迭代。<br>（3）后处理模块将样机的虚拟数据输出成曲线或者生成直观的动画来查看。<br>后处理数据需要在模型中调用，采用measure命令即可调取其中的参数，本例中关心拨弹电机的扭矩是够用，故在【模型树】&gt;【motions】&gt;【右键motion_1】&gt;【measure】按照如图5-22设置&gt;【apply】。</p><p><img src="/old_images/2020/07/2066845163.png" alt="38.PNG"></p><p>图5-22 Measure按钮<br>输出的扭矩图如5-23</p><p><img src="/old_images/2020/07/1264423062.png" alt="39.PNG"></p><p>另外可以通【功能区】&gt;【Results】&gt;【Postprocessor】进入后处理模块【空白页右键】&gt;【Load Animation】进行动画输出如图5-33，红色框中是播放暂停好和录制按钮。</p><p><img src="/old_images/2020/07/3794064227.png" alt="40.PNG"></p><p>还有其他感兴趣的任意物理量均可输出，通过对数据和动画的分析寻找结构优化的突破点，事半功倍。<br>6.结论<br>所提到的Solidwoks搭建动力学模型导入Adams中进行计算,对于新手来讲比较容易上手,能在短时间内搭建出动力学模型,并且简单的机械系统的仿真计算结果是可信的.而一些复杂些的系统求解精度就很低,和实际情况不太相符.在做拨弹仿真中就出现实体实体间的互相侵入太多的情况,目前还没找到原因.故复杂模型建议使用以下叙述的模型搭建方法。<br>虚拟样机需要在建立后，根据物理样机修改才能得到更精确的仿真结果。<br>各种仿真软件都只是工具，建模的关键还在于正确的工况分析与合理的参数设置，这些都是在仿真过程中逐渐完成的。如何把建立正确的物理样机以及仿真后数据的分析与改进方向是需要人工分析完成的。<br>7.写在最后的预告<br>各位朋友们，如果大家觉得这部分比较有趣的话，下一次可以和大家分享机器人学的部分知识，先从运动学和动力学开始吧，比如D-H法，拉格朗日方程，牛顿-欧拉方程，以及这些数理知识是如何应用在机器人设计中的，有机会的话下次见啦！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hello！大家好呀，我是你们的新朋友，也是宇哥的搭档。先自我介绍一下子哈，我的名字是冯宸，跟栋宇一样是哈工大竞技机器人队的现役队员，大家可以叫我Albert，主要是从事机械方向的工作，当然嵌入式和视觉方面也有（cai）所（de）涉（yi）猎（pi）。前几天偶然发现了栋宇的</summary>
      
    
    
    
    <category term="开发" scheme="http://starydy.xyz/categories/%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>LCD vs OLED</title>
    <link href="http://starydy.xyz/2020/07/11/LCD%20vs%20OLED/"/>
    <id>http://starydy.xyz/2020/07/11/LCD%20vs%20OLED/</id>
    <published>2020-07-11T06:41:00.000Z</published>
    <updated>2020-12-14T12:20:25.831Z</updated>
    
    <content type="html"><![CDATA[<p>转载以下知乎大佬们为我们带来的LCD与OLED大比拼：</p><p>链接：<a href="https://www.zhihu.com/question/22263252">OLED 和 LCD 有什么区别？</a></p><p>来源：知乎</p><p><img src="/old_images/2020/07/3074664648.jpg" alt="Snipaste_2020-07-11_22-41-15.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载以下知乎大佬们为我们带来的LCD与OLED大比拼：&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.zhihu.com/question/22263252&quot;&gt;OLED 和 LCD 有什么区别？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：知乎&lt;/p&gt;
&lt;p&gt;&lt;img sr</summary>
      
    
    
    
    <category term="日常" scheme="http://starydy.xyz/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>轨道交通领域的牛顿特斯拉之战和你坐地铁听到的“防空警报声”</title>
    <link href="http://starydy.xyz/2020/06/30/%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A%E9%A2%86%E5%9F%9F%E7%9A%84%E7%89%9B%E9%A1%BF%E7%89%B9%E6%96%AF%E6%8B%89%E4%B9%8B%E6%88%98%E5%92%8C%E4%BD%A0%E5%9D%90%E5%9C%B0%E9%93%81%E5%90%AC%E5%88%B0%E7%9A%84%E2%80%9C%E9%98%B2%E7%A9%BA%E8%AD%A6%E6%8A%A5%E5%A3%B0%E2%80%9D/"/>
    <id>http://starydy.xyz/2020/06/30/%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A%E9%A2%86%E5%9F%9F%E7%9A%84%E7%89%9B%E9%A1%BF%E7%89%B9%E6%96%AF%E6%8B%89%E4%B9%8B%E6%88%98%E5%92%8C%E4%BD%A0%E5%9D%90%E5%9C%B0%E9%93%81%E5%90%AC%E5%88%B0%E7%9A%84%E2%80%9C%E9%98%B2%E7%A9%BA%E8%AD%A6%E6%8A%A5%E5%A3%B0%E2%80%9D/</id>
    <published>2020-06-30T09:21:11.000Z</published>
    <updated>2020-12-14T12:21:08.818Z</updated>
    
    <content type="html"><![CDATA[<p>好了，我不是鸽子，我只是最近突然开始考试了。再一个，闫栋宇这博客的影响力太低，划了半天才遇到这样一个问题。<br> <img src="/old_images/2020/07/1028634298.png" alt="233.png"><br>感谢这位同学，好样的。你的问题我在后面解答了，记得查收。<br>今天考完了信号与系统，下午忽然看到中车长客下线了哈尔滨地铁2号线的第一列电客车，外形样子很有JR的味道，内部LCD很像港铁。挺帅的，可以期待一下。<br>所以挺高兴的，忽然想起来自己应该看看这个博客里面也没有人提问题了，就点进来看了一下。遂琢磨写一篇推送，说点轨交的小东西。开始。<br>提到轨道交通，大家想到的可能是和谐号，复兴号，白色车身，蓝色肩带的钢铁巨龙；或者是拉着汽笛咣啷啷前行的绿皮车。事实上我对轨道交通的兴趣，大概来自于我从小就住在铁路边上，绥满铁路哈尔滨段，也是中东铁路最靠近哈尔滨站的这一段。那时候也没有啥娱乐手段，每天最大的快乐就是看火车。我家门口的铁路桥往北走一点就是著名的滨洲铁路桥，现在已经是个景点了。高中想考同济轨交，没考上，现在换了个地方继续考，我就不信了我还治不了你了。<br>扯远了，说回来。目前的轨道交通是以电气化发展为主的，你们看看自己城市的地铁，没有在用内燃机车或者蒸汽机车的吧，都是电客车。电客车，以电为能源的载客列车，字面意思即可。通常我们认为火车是车头带着一溜车厢走，动力来自于车头，也就是所谓的机车。机车通过电能驱动电机，或者内燃机燃烧燃料带动车轮（这里要注意，为了更好地控制运行速度，相当一部分内燃机车采用电传动，简单来说就是燃烧燃料是为了发电，，电能驱动列车前进，本质上还是电机带动车轮转动），机车通过车钩把力传给后面的车厢，再传给再后面的车厢，一节一节套娃即可。这种模式成为机辆模式，只有机车有动力，后面全是没有动力的拖车。这样的车坐起来的体验比较差。我们可以把一列火车想象成一个高中学动量定理时候常用的简单的物理模型，就是若干物块通过弹簧串联起来。列车停放时，弹簧是松弛的（有空的时候可以给你们讲讲制动的原理，制动靠的是空气，很有意思），机车带动第一节车厢从零加速，第一个弹簧绷直，第一节车厢有速度之后，第二个弹簧绷直，第二节车厢受力开始加速。落实到乘坐体验上，就会在启动的时候忽然觉得自己所在的车厢被一个很大的力撞了一下，车迷俗称“咣一声”。不同车型的体验是不一样的，减震缓冲做的越好这种感觉越微弱，但再微弱也会有。同理，制动的时候也一样。但如果你坐的火车在站内停车的时候忽然向运行反方向抖了一下，紧接着又向运行方向抖了一下，不要慌，这是在进行更换机车的机车连挂作业，也就是换车头。<br>传统的机辆方式很传统，但会带来一些问题。刚才说的乘坐体验是一方面，另一方面就是运行方面的问题了。这样的方式限制了列车的加速性能，毕竟要一节一节地去把车厢从静止“拽”成有速度，且一节机车能提供的总功率有限，很难把运行速度进一步提升，目前普速列车最高的速度等级是Z，最高运行速度也就160左右，拉的越多速度还越慢。这倒也好解决，你一辆机车不够我就加一个呗，俩不够就来仨，是可以的。这样的运行模式下，负责总控制的机车称为本务，剩下那些来帮忙的都叫做补机。这样的方法行倒是行，但也仅仅是“凑合着用”。这里我们引入一个不是很严谨的概念，叫动拖比。为什么不严谨暂且不表，先说它是什么。动拖比，字面意思是动力车和拖车的数量比。比如ICE3，很经典的德国高速动车组，我国CRH3C和CRH380B系列都是以ICE3为原型车的。ICE3为8节编组，4动4拖，即4节车上有电机，其余4节轮子上没有驱动装置（但是制动装置是都有的，安全起见），动拖比就是50%，注意动力车本身也算在拖车总数里。一个数据告诉你德国货多牛逼，50%动拖比的ICE3的总牵引功率，比同样是8辆编组且动拖比75%的CRH2A（以新干线为原型车）要高出将近三分之一，这才叫真正的强劲动力。介绍完动拖比的概念，我们不难理解，对于相同水平的动力配置，动拖比越高的列车功率越高。这就为上述问题提供了一个思路，我能不能把动力单元分散到几个车厢中去，让更多的拖车变成动力车，这样起动性能会更好（因为打破了机辆模式），最高运行速度也会更高（动拖比增加，功率增加）。于是，动车组诞生了（这里暂且不谈动力集中型动车组，也就是垃圾桶，机破之王CR200J）。<br>我们现在看到的动车组都觉得很常见，但这个分散动力单元的思想是很具有跨时代意义的。就像当年被魔改的波音737，把发动机从尾部挪到了大翼悬臂梁下面一样，开创了一个时代。按照这样的定义，其实我们平时坐的地铁也是动车吗？是的。举一个很简单的例子，哈尔滨地铁今天下线的2号线首列电客车，它的动力配置是4动2拖六节编组（1号线也一样，所以我才觉得他俩是一个模子扣的），两端是带控制室的拖车，符号是Tc，第二节和第五节是带受电弓的动车，符号是Mp（p代表受电弓pantograph），第三节第四节则是普通动车，符号是M。提到受电弓，大家可以理解为无轨电车的大辫子，跟它原理上没有任何区别。同理，有些地方可能有轻轨，重庆的单轨，还有一些有轨电车（北京的西郊线，车迷称西溜线，这个故事很有意思，以后可以单拿出来写一篇）等，都可以算是动车的范畴。<br><strong>以下划重点，我来讨论一下图里的问题。先说交流直流。</strong><br>我们知道输电的时候有两种形式，交流和直流。其实这两种电轨道交通都在用，只不过国铁（普速铁路或者高铁动车）用的是交流电（惭愧啊，忘了电压是多少了，好像是3000V吧），城市轨道交通一般用的是直流电。注意是一般，不是全部，这个和设计有关系。区别主要在于用的电机不同，国铁的电力机车或者电力动车组用的都是交流电机，感应电机或者永磁同步电机，而城市轨道交通一般用的是无刷直流电机。有人可能会说无刷直流电机和永磁同步电机本质上没有差别。是的，说的没错，但是用在这个场合里的区别在于，国铁主要承担的是大运量、远距离的运输，需要电机长时间稳定高速运行，而城市轨道交通的站间距相对较短，需要频繁的起动制动，所以在这个语境下把这个电机当成一个直流电机来控制，可以得到很好的快速启动、快速制动特性，加速度可以很大。这就是为什么地铁起动的时候，我们一定好扶好坐稳，因为加速度很大，而坐高铁动车的时候，列车起动可能都没什么感觉，加速很慢，但是加速过程很长。此外，发电厂发出来的电可是交流电，荒山野岭的地方隔几公里就要给高铁修个变电站，咱也得考虑成本啊，修个变压器就得了，再整个整流装置太费钱，干脆你就用交流电吧。但城市轨道交通不同，在城市里一条线路可能也就需要一两个主变电站，对于每公里3亿到7亿的成本，两个大容量整流装置应该用不了几个钱。这就是一种相克相生的关系，我需要长时间稳定高速，就用交流电，但起动性能就差；我需要快速起动快速制动，就用直流电，加速很快，但就麻烦点。这里说一下，这么大功率的电机基本没有用有刷电机的。要是用了我估计得天天换电刷。<br>其实直流交流的区别，上述是业内主要考虑的方面。看到问题里的那个朋友说损耗问题，也有一定道理，确实国铁的线路比较长，高压的交流输电能减少不少损耗，但要知道3000V并不算很高（直接输给受电弓的电压可不是超高压或者特高压的），整个线路的电压都是这个数值，这个电压等级的长距离输电损耗应该也不小，毕竟电压低，所以我个人认为这不是一个主要方面。而且交流和直流相比，如果考虑电缆的集肤效应，同等电压等级的情况下是不是交流的损耗还要高一些？这也是个很有意思的问题，有空可以探讨一下。这个交直流的问题并没有定论，其实也是电客车运用的长期经验反馈给设计者的一种信息。就像舌尖上的中国里的大自然给人类的馈赠一样，倒逼着我们去改进设计，这可能也是工科特有的魅力。<br><strong>好了，现在说说那个“防空警报声”。</strong><br>其实我不说你可能觉得它很陌生，但我要是说“唱歌电机”，你可能就恍然大悟了。是的，就是VVVF，variable voltage variable frequency，变压变频调速，就是那个声音。电机嘛，启动过程中一定要调速控制的，我接触到的电力机车或者电力动车组都是VVVF调速。<br>事实上，不同厂家生产的变流装置发出的声音是不一样的。说到这就不得不提一下三个龙头企业——西门子，阿尔斯通，庞巴迪。这三家企业生产的相关半导体器件制成的变流装置在进行VVVF调速的时候发出的声音是不一样的。防空警报一样的是西门子平台，阿尔斯通和庞巴迪的声音有独特的变化规律，这个区别很明显，每一家公司的产品都很独特，还有其他企业的（比如日立，南车等），但用语言不可描述，感兴趣的话可以来找我，我给你几个B站链接。<br>车迷中有一个群体很喜欢听VVVF声音，有些人可能把它当成asmr了吧。我也喜欢，但我喜欢只是因为我是学电的。再一个，我觉得它很好听。也许工科生不懂浪漫，但工科也有自己的美吧，即使是一段并不具有太大欣赏价值的VVVF声音。<br>今天就说到这吧，我还在等同济轨交院的短信和邮件，不知道我能不能进夏令营。<strong>这篇文章放在这，感谢栋宇给我这个平台，也感谢提问题的这位兄弟，我真的是看见有人提了个问题才决定今天无论如何也要写一篇出来。</strong>轨道交通是一个很冷门的行业，它融合了机械，车辆，空气动力学，能源动力，电气，控制，土木，材料等等很多学科。我自己预测至少30年内传统轮轨还有发展的余地，传统轮轨会向着智能化、自动化、无人化、绝对安全化、绿色节能化、高速和高效化发展。还有一个，就是磁悬浮，那就是另一个故事了。最近胡志强跟我说了有一些想法，觉得轨交这个行业也挺好的。如果可能的话，我也挺希望他能跟我一起去轨交领域开创一片天地出来。<br>调研和问题招募长期有效，欢迎大家对轨道交通领域有什么问题都可以来栋宇的博客下面找我的文章留言，不定期给大家做点硬核科普。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好了，我不是鸽子，我只是最近突然开始考试了。再一个，闫栋宇这博客的影响力太低，划了半天才遇到这样一个问题。&lt;br&gt; &lt;img src=&quot;/old_images/2020/07/1028634298.png&quot; alt=&quot;233.png&quot;&gt;&lt;br&gt;感谢这位同学，好样的。你的问题</summary>
      
    
    
    
    <category term="日常" scheme="http://starydy.xyz/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>数字图像处理-课程设计</title>
    <link href="http://starydy.xyz/2020/06/24/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    <id>http://starydy.xyz/2020/06/24/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-06-24T01:47:00.000Z</published>
    <updated>2020-12-14T12:22:05.992Z</updated>
    
    <content type="html"><![CDATA[<p>这是2020年春季学期我选的外专业课“数字图像处理”的课程设计，觉得比较有趣，故拿来记录留念。<br>在这门课程中，我第一次对图像处理进行实践，老师讲得非常好，推荐大家选这门课，能学到不少知识。</p><h2 id="课设题目"><a href="#课设题目" class="headerlink" title="课设题目"></a>课设题目</h2><p>天文摄影师常常用照相机对夜晚的天空进行拍摄。v1.avi和v2.avi是两段持续几秒的夜晚天空景象的视频。可以注意到，夜晚较暗的光照使得视频中有明显的噪声。设计一个算法用于去除这两组图像数据中的噪声。<br>根据学过的图像处理知识可知，为了实现通过多帧图像数据获取一幅去除噪声后的图像，一种常用的方法是平均去噪法，即计算多帧图像的平均值。<br>分别计算这两组多帧图像数据的平均值，获得两幅去噪图像。<br>用上述方法可以发现去噪结果并不令人满意，原因是各帧图像间存在一定的偏移。请设计一个算法克服这种偏移同时获得较好的平均法去噪结果。</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>以视频中的第一帧为基准，逐帧遍历视频图片，由于图片位移间隔时间小，位移小，可以通过特殊方法获得当前帧图片与第一帧基准图片的相对运动大小，求出变换矩阵，通过变换的逆矩阵反向平移当前帧，即可认为观察者未运动，再使用平均值法去噪即可。<br>由于运动时间短，我们忽略运动的旋转部分，仅考虑平移运动。平移运动为二自由度，因此我们只需要找到两张图中一个对应的特征点，即可求得变换矩阵。</p><h2 id="涉及的-MATLAB-函数"><a href="#涉及的-MATLAB-函数" class="headerlink" title="涉及的 MATLAB 函数"></a>涉及的 MATLAB 函数</h2><p><strong>VideoReader</strong>;<br>用于读取视频中的内容，将其每一帧都读出来。<br><strong>im2double</strong>；<br>将读入的图像转换为浮点形式，便于后期处理。<br><strong>rgb2gray</strong>；<br>将rgb图像转化为灰度图，便于后期处理。<br><strong>strel</strong>；<br>创建形态学操作的构造元素。<br><strong>imerode</strong>；<br>图像形态学腐蚀处理。<br><strong>edge</strong><br>边缘检测。<br><strong>find、max</strong>；<br>求得数组最大值并确定最大值的位置。 </p><h2 id="实验内容与方法"><a href="#实验内容与方法" class="headerlink" title="实验内容与方法"></a>实验内容与方法</h2><p>首先观察两个视频，可以看出，视频中图像含有许多噪声：<br><img src="/old_images/2020/06/2065354894.jpg" alt="Snipaste_2020-06-24_17-44-11.jpg"><br><img src="/old_images/2020/06/1235922839.jpg" alt="Snipaste_2020-06-24_17-44-38.jpg"><br>这些噪声分布均匀且均值基本为0，可以通过均值滤波的方法消除噪声。但是，由于视频拍摄的抖动导致直接进行多帧均值滤波会使运动物体产生模糊，导致滤波效果变差：<br><img src="/old_images/2020/06/4291764818.png" alt="3.png"><br><img src="/old_images/2020/06/4074491988.png" alt="4.png"><br>因此，想到了使用特征点的方法求出前后两帧的相对运动关系，将后一帧移动到前一帧对应的位置，以消除运动产生的影响。<br>首先使用im2double与rgb2gray将图像处理为浮点型的单值图，之后对两段视频分别选择寻找特征点的方法。<br>对于第一个视频，使用缩小范围的寻找特征点的方法，在原图中找到一个sector区域，作为特征点运动的范围。选取这个位置要保证范围内有且仅有一个比较明亮的点，并且在运动过程中这个点不会跑出这个范围。<br>sector = frame(421:472,681:728);<br>处理前的sector<br><img src="/old_images/2020/06/2270251422.png" alt="5.png"><br>对其进行处理，首先进行形态学的腐蚀处理<br>形态学操作可以改变物体形状<br><img src="/old_images/2020/06/3183017928.png" alt="6.png"><br>形态学腐蚀就是求局部最小值的操作<br>se = strel(‘disk’,1);<br>sector = imerode(sector,se);<br>之后使用find函数找到图片中幅值最大的像素，以这个点的位置作为特征点。<br>[x_1,y_1] = find(sector == max(max(sector)));<br>处理后的sector<br><img src="/old_images/2020/06/3043677073.png" alt="8.png"><br>选择这个点作为特征点进行唯一判断。<br>对于第二个视频，我们使用图中月亮的圆心作为特征点。<br>首先对图像进行canny边缘检测：<br>result_frame = edge(frame,’canny’,[0.3,0.5]);<br><img src="/old_images/2020/06/1460216437.png" alt="9.png"><br>Canny边缘检测包含以下四个步骤：<br>1.高斯滤波<br>滤波的主要目的是降噪，一般的图像处理算法都需要先进行降噪。而高斯滤波主要使图像变得平滑（模糊），同时也有可能增大了边缘的宽度。<br>2.计算图片梯度<br>边缘一定就是图像中像素变化较快的区域，因此使用梯度就可以检测出边缘。我们使用sobel算子对图片进行滤波，就可以计算出它的梯度。<br><img src="/old_images/2020/06/385346141.png" alt="10.png"><br>3.过滤非最大值<br>在高斯滤波过程中，边缘有可能被放大了。这个步骤使用一个规则来过滤不是边缘的点，使边缘的宽度尽可能为1个像素点：如果一个像素点属于边缘，那么这个像素点在梯度方向上的梯度值是最大的。否则不是边缘，将灰度值设为0。这样就可以使检测到的边缘始终是一个像素。<br>4.使用上下阈值确定边缘<br>通过给定的上下阈值确定最终哪些地方属于边缘，哪些地方不是。梯度过小的地方不应该是边缘，而梯度过大的地方也不应被视为边缘 。</p><p>想要检测图片中的圆首先想到，可以使用Hough圆变换来求解圆的圆心：<br>首先理解霍夫线变换。霍夫线变换的基本理论，就是二进制图片中每一个点都可能属于某些线。如果将过(x0,y0)的这些条线参数化为一个斜率为a，截距为b的线，由于这条线过这一点，可以将a，b作为变量，画出这个点对应的所有直线参数，在a，b平面中的形式：<br><img src="/old_images/2020/06/2947829010.jpg" alt="Snipaste_2020-06-24_17-49-13.jpg"><br>也是一条直线，并且斜率与截距都是确定的。对于每一个图像中的非零点，都进行这样的操作，并且在a，b平面表示出来。当所有的非零点都表示出来，并进行累加后，a，b平面上数值比较大的点就是原图中可能的直线的参数。<br>同理，霍夫圆变换与直线变换的原理相同，先将圆参数化，只不过这时需要三个参数，得到的参数平面将会是一个三位体中的坐标。这样也是可行的，只不过运算缓慢，通常使用霍夫梯度法来检测圆。圆心是圆所有法线的交汇点，通过梯度，确定这些法线，并求出他们的交点中最有可能的那一个，就能检测到圆心。随后再判断圆心到圆周上点的距离，相同或相近距离数量多，就能确定圆的半径，并且也能检验圆心选择的正确性。<br>在思考过程中，又发现进行完canny边缘检测后，这张图像十分完美，故使用运算更为简便的方法进行圆检测。<br>使用扫描算法检测这个圆的圆心，具体方法为：<br>逐<strong>列</strong>遍历整个图像，若在每一<strong>列</strong>检测到两次白点，计算两个白点之间的距离，所有距离中最长的距离就是圆的直径，这时两个点中间的的那个点就是圆的圆心。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>实验所使用代码（Matlab）如下：<br>对于第一个视频：</p><pre><code>clear,clc;vidobj = VideoReader([&#39;v1&#39; &#39;.avi&#39;]);numFrames = vidobj.NumFrames;sum_frame = zeros(533,800,3);origin_frame = im2double(read(vidobj,1));frame = rgb2gray(origin_frame);sector = frame(421:472,681:728);se = strel(&#39;disk&#39;,1);sector = imerode(sector,se);[x_1,y_1] = find(sector == max(max(sector)));sum_frame = origin_frame;for i = 2:numFrames    origin_frame = im2double(read(vidobj,i));    frame = rgb2gray(origin_frame);    %find offset    sector = frame(421:472,681:728);    se = strel(&#39;disk&#39;,1);    sector = imerode(sector,se);    [x,y] = find(sector == max(max(sector)));    x_offset = x - x_1;    y_offset = y - y_1;    if x_offset &gt; 0 &amp;&amp; y_offset &gt; 0        origin_frame(1:533-x_offset,1:800-y_offset,:) = origin_frame(x_offset+1:533,y_offset+1:800,:);    elseif x_offset &lt; 0 &amp;&amp; y_offset &gt; 0        origin_frame(-x_offset+1:533,1:800-y_offset,:) = origin_frame(1:533+x_offset,y_offset+1:800,:);    elseif x_offset &gt; 0 &amp;&amp; y_offset &lt; 0        origin_frame(1:533-x_offset,-y_offset+1:800,:) = origin_frame(x_offset+1:533,1:800+y_offset,:);    elseif x_offset &lt; 0 &amp;&amp; y_offset &lt; 0        origin_frame(-x_offset+1:533,-y_offset+1:800,:) = origin_frame(1:533+x_offset,1:800+y_offset,:);    end    sum_frame = sum_frame + origin_frame;endsum_frame = sum_frame/60;imshow(sum_frame);</code></pre><p> 对于第二个视频：</p><pre><code>clear,clc;vidobj = VideoReader([&#39;v2&#39; &#39;.avi&#39;]);numFrames = vidobj.NumFrames;sum_frame = zeros(600,800,3);origin_frame = im2double(read(vidobj,1));frame = rgb2gray(origin_frame);result_frame = edge(frame,&#39;canny&#39;,[0.3,0.5]);%find x,yfor j = 1:600    n = 0;    for k = 1:800        if result_frame(j,k) == 1            n = n+1;            if n == 1                startpoint = k;            else                if k - startpoint &gt; 10                    maxVal(j,1) = k - startpoint;                    maxVal(j,2) = startpoint;                else                    n = n-1;                end            end        end        if k == 800 &amp;&amp; (n == 1 || n == 0)            maxVal(j,1) = 0;            maxVal(j,2) = 0;        end    endendr = max(maxVal(:,1));xpos = find(maxVal(:,1)==r);xpos = int16(median(xpos));ypos = maxVal(xpos,2) + int16(r/2);baseX = xpos;baseY = ypos;sum_frame = origin_frame;for i = 2:numFrames    origin_frame = im2double(read(vidobj,i));    frame = rgb2gray(origin_frame);    result_frame = edge(frame,&#39;canny&#39;,[0.3,0.5]);   %find x,y    for j = 1:600        n = 0;        for k = 1:800            if result_frame(j,k) == 1                n = n+1;                if n == 1                    startpoint = k;                else                    if k - startpoint &gt; 10                        maxVal(j,1) = k - startpoint;                        maxVal(j,2) = startpoint;                    else                        n = n-1;                    end                end            end            if k == 800 &amp;&amp; (n == 1 || n == 0)                maxVal(j,1) = 0;                maxVal(j,2) = 0;            end        end    end    r = max(maxVal(:,1));    xpos = find(maxVal(:,1)==r);    xpos = int16(median(xpos));    ypos = maxVal(xpos,2) + int16(r/2);    x_offset = xpos - baseX;    y_offset = ypos - baseY;     if x_offset &gt; 0 &amp;&amp; y_offset &gt; 0        origin_frame(1:600-x_offset,1:800-y_offset,:) = origin_frame(x_offset+1:600,y_offset+1:800,:);    elseif x_offset &lt; 0 &amp;&amp; y_offset &gt; 0        origin_frame(-x_offset+1:600,1:800-y_offset,:) = origin_frame(1:600+x_offset,y_offset+1:800,:);    elseif x_offset &gt; 0 &amp;&amp; y_offset &lt; 0        origin_frame(1:600-x_offset,-y_offset+1:800,:) = origin_frame(x_offset+1:600,1:800+y_offset,:);    elseif x_offset &lt; 0 &amp;&amp; y_offset &lt; 0        origin_frame(-x_offset+1:600,-y_offset+1:800,:) = origin_frame(1:600+x_offset,1:800+y_offset,:);    end    sum_frame = sum_frame + origin_frame;endsum_frame = sum_frame/60;imshow(sum_frame);</code></pre><p>运行结果：<br><img src="/old_images/2020/06/142298572.png" alt="11.png"><br><img src="/old_images/2020/06/2236493176.png" alt="12.png"><br>可以看到，经过处理的图像噪声明显减少，并且并未受到观察者视角移动而出现动态模糊的影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是2020年春季学期我选的外专业课“数字图像处理”的课程设计，觉得比较有趣，故拿来记录留念。&lt;br&gt;在这门课程中，我第一次对图像处理进行实践，老师讲得非常好，推荐大家选这门课，能学到不少知识。&lt;/p&gt;
&lt;h2 id=&quot;课设题目&quot;&gt;&lt;a href=&quot;#课设题目&quot; class</summary>
      
    
    
    
    <category term="控制" scheme="http://starydy.xyz/categories/%E6%8E%A7%E5%88%B6/"/>
    
    
  </entry>
  
</feed>
